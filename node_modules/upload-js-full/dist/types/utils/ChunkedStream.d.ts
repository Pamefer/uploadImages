/// <reference types="node" />
export declare class ChunkedStream {
    private readonly source;
    private buffer;
    private consumer;
    private isSourceFullyConsumed;
    private isFinishedConsuming;
    private resolver;
    constructor(source: NodeJS.ReadableStream);
    /**
     * If the source stream is larger than the 'size' the user is consuming (i.e. they're only wanting to upload a subset
     * of the stream) then the stream won't be resolved by the 'end' event inside 'runChunkPipeline', so calling this
     * method is necessary.
     */
    finishedConsuming(): void;
    /**
     * Promise resolves when the entire stream has finished processing, or an error occurs.
     * You must call 'take' a sufficient number of times after calling this method in order for this promise to resolve.
     */
    runChunkPipeline(): Promise<void>;
    /**
     * Only call 'take' after the previously returned stream has been fully consumed.
     */
    take(bytes: number): Promise<NodeJS.ReadableStream>;
    private consumeFromBuffer;
    private splitBuffer;
    private createStream;
    private emptyStream;
    private finishStream;
}
