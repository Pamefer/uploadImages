// ----------------------------------------
// POLYFILL GUIDE:
// ----------------------------------------
//
// "buffer" & "stream" are not required for browser environments.
//
// They are only used when the code detects it's running in Node.js (at runtime).
//
// You may polyfill them with empty objects (for browser environments):
//
// ----------------------------------------
// Webpack:
// {
//   resolve: {
//     fallback: {
//       buffer: false,
//       stream: false
//     }
//   }
// }
// ----------------------------------------
//
import * as __WEBPACK_EXTERNAL_MODULE_buffer__ from "buffer";
import * as __WEBPACK_EXTERNAL_MODULE_stream__ from "stream";
/******/ var __webpack_modules__ = ({

/***/ "buffer":
/***/ (function(module) {

var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }
var y = x => () => x
module.exports = __WEBPACK_EXTERNAL_MODULE_buffer__;

/***/ }),

/***/ "stream":
/***/ (function(module) {

var x = y => { var x = {}; __webpack_require__.d(x, y); return x; }
var y = x => () => x
module.exports = __WEBPACK_EXTERNAL_MODULE_stream__;

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ !function() {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = function(exports, definition) {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ }();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ !function() {
/******/ 	__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ }();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "AccountJobStatus": function() { return /* reexport */ AccountJobStatus; },
  "AccountJobType": function() { return /* reexport */ AccountJobType; },
  "AsyncResponseJobDocsEnum": function() { return /* reexport */ AsyncResponseJobDocsEnum; },
  "AwsRegion": function() { return /* reexport */ AwsRegion; },
  "BASE_PATH": function() { return /* reexport */ BASE_PATH; },
  "BaseAPI": function() { return /* reexport */ BaseAPI; },
  "BinaryResult": function() { return /* reexport */ BinaryResult; },
  "COLLECTION_FORMATS": function() { return /* reexport */ COLLECTION_FORMATS; },
  "CancelledError": function() { return /* reexport */ CancelledError; },
  "ChunkedStream": function() { return /* reexport */ ChunkedStream; },
  "Configuration": function() { return /* reexport */ Configuration; },
  "DefaultConfig": function() { return /* reexport */ DefaultConfig; },
  "FetchError": function() { return /* reexport */ FetchError; },
  "FileApi": function() { return /* reexport */ FileApi; },
  "FileCopyStatus": function() { return /* reexport */ FileCopyStatus; },
  "FileSummaryTypeEnum": function() { return /* reexport */ FileSummaryTypeEnum; },
  "FolderApi": function() { return /* reexport */ FolderApi; },
  "FolderDetailsTypeEnum": function() { return /* reexport */ FolderDetailsTypeEnum; },
  "FolderSettingsStorageLayerSummaryStorageLayerTypeEnum": function() { return /* reexport */ FolderSettingsStorageLayerSummaryStorageLayerTypeEnum; },
  "FolderSummaryTypeEnum": function() { return /* reexport */ FolderSummaryTypeEnum; },
  "InternalStorageV1TypeEnum": function() { return /* reexport */ InternalStorageV1TypeEnum; },
  "InternalStorageV2TypeEnum": function() { return /* reexport */ InternalStorageV2TypeEnum; },
  "JSONApiResponse": function() { return /* reexport */ JSONApiResponse; },
  "JobApi": function() { return /* reexport */ JobApi; },
  "MultipartUploadProtocol": function() { return /* reexport */ MultipartUploadProtocol; },
  "ObjectSummaryTypeEnum": function() { return /* reexport */ ObjectSummaryTypeEnum; },
  "PathPermissionScope": function() { return /* reexport */ PathPermissionScope; },
  "PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum": function() { return /* reexport */ PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum; },
  "ProcessFileCachePermEnum": function() { return /* reexport */ ProcessFileCachePermEnum; },
  "RequiredError": function() { return /* reexport */ RequiredError; },
  "ResponseError": function() { return /* reexport */ ResponseError; },
  "S3StorageTypeEnum": function() { return /* reexport */ S3StorageTypeEnum; },
  "SpecifiedFieldValueFolderDescriptionOrNullSetEnum": function() { return /* reexport */ SpecifiedFieldValueFolderDescriptionOrNullSetEnum; },
  "SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum": function() { return /* reexport */ SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum; },
  "SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum": function() { return /* reexport */ SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum; },
  "SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum": function() { return /* reexport */ SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum; },
  "StorageLayerSummaryTypeEnum": function() { return /* reexport */ StorageLayerSummaryTypeEnum; },
  "StorageLayerUpdateTypeEnum": function() { return /* reexport */ StorageLayerUpdateTypeEnum; },
  "TagConditionAllTypeEnum": function() { return /* reexport */ TagConditionAllTypeEnum; },
  "TagConditionAndTypeEnum": function() { return /* reexport */ TagConditionAndTypeEnum; },
  "TagConditionAnyTypeEnum": function() { return /* reexport */ TagConditionAnyTypeEnum; },
  "TagConditionEqualsTypeEnum": function() { return /* reexport */ TagConditionEqualsTypeEnum; },
  "TagConditionNotTypeEnum": function() { return /* reexport */ TagConditionNotTypeEnum; },
  "TagConditionOrTypeEnum": function() { return /* reexport */ TagConditionOrTypeEnum; },
  "TagConditionTypeEnum": function() { return /* reexport */ TagConditionTypeEnum; },
  "TextApiResponse": function() { return /* reexport */ TextApiResponse; },
  "UnspecifiedFieldValueSetEnum": function() { return /* reexport */ UnspecifiedFieldValueSetEnum; },
  "UpdatableFieldFolderDescriptionOrNullSetEnum": function() { return /* reexport */ UpdatableFieldFolderDescriptionOrNullSetEnum; },
  "UpdatableFieldPublicPermissionsArrayOrNullSetEnum": function() { return /* reexport */ UpdatableFieldPublicPermissionsArrayOrNullSetEnum; },
  "UpdatableFieldStorageLayerUpdateOrNullSetEnum": function() { return /* reexport */ UpdatableFieldStorageLayerUpdateOrNullSetEnum; },
  "UploadApi": function() { return /* reexport */ UploadApi; },
  "UploadApiError": function() { return /* reexport */ UploadApiError; },
  "UploadManager": function() { return /* reexport */ UploadManager; },
  "VoidApiResponse": function() { return /* reexport */ VoidApiResponse; },
  "WebStorageTypeEnum": function() { return /* reexport */ WebStorageTypeEnum; },
  "canConsumeForm": function() { return /* reexport */ canConsumeForm; },
  "querystring": function() { return /* reexport */ querystring; }
});

;// CONCATENATED MODULE: ./src/gen/runtime.ts
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function _empty() {}
function _invokeIgnored(body) {
  var result = body();
  if (result && result.then) {
    return result.then(_empty);
  }
}
var _iteratorSymbol = /*#__PURE__*/typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
function _settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof _Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = _settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    var observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
var _Pact = /*#__PURE__*/function () {
  function _Pact() {}
  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;
    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          _settle(result, 1, callback(this.v));
        } catch (e) {
          _settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function (_this) {
      try {
        var value = _this.v;
        if (_this.s & 1) {
          _settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          _settle(result, 1, onRejected(value));
        } else {
          _settle(result, 2, value);
        }
      } catch (e) {
        _settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact;
}();
function _isSettledPact(thenable) {
  return thenable instanceof _Pact && thenable.s & 1;
}
function _forTo(array, body, check) {
  var i = -1,
    pact,
    reject;
  function _cycle(result) {
    try {
      while (++i < array.length && (!check || !check())) {
        result = body(i);
        if (result && result.then) {
          if (_isSettledPact(result)) {
            result = result.v;
          } else {
            result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
            return;
          }
        }
      }
      if (pact) {
        _settle(pact, 1, result);
      } else {
        pact = result;
      }
    } catch (e) {
      _settle(pact || (pact = new _Pact()), 2, e);
    }
  }
  _cycle();
  return pact;
}
function _forOf(target, body, check) {
  if (typeof target[_iteratorSymbol] === "function") {
    var _cycle = function _cycle(result) {
      try {
        while (!(step = iterator.next()).done && (!check || !check())) {
          result = body(step.value);
          if (result && result.then) {
            if (_isSettledPact(result)) {
              result = result.v;
            } else {
              result.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));
              return;
            }
          }
        }
        if (pact) {
          _settle(pact, 1, result);
        } else {
          pact = result;
        }
      } catch (e) {
        _settle(pact || (pact = new _Pact()), 2, e);
      }
    };
    var iterator = target[_iteratorSymbol](),
      step,
      pact,
      reject;
    _cycle();
    if (iterator["return"]) {
      var _fixup = function _fixup(value) {
        try {
          if (!step.done) {
            iterator["return"]();
          }
        } catch (e) {}
        return value;
      };
      if (pact && pact.then) {
        return pact.then(_fixup, function (e) {
          throw _fixup(e);
        });
      }
      _fixup();
    }
    return pact;
  }
  // No support for Symbol.iterator
  if (!("length" in target)) {
    throw new TypeError("Object is not iterable");
  }
  // Handle live collections properly
  var values = [];
  for (var i = 0; i < target.length; i++) {
    values.push(target[i]);
  }
  return _forTo(values, function (i) {
    return body(values[i]);
  }, check);
}
function _continue(value, then) {
  return value && value.then ? value.then(then) : then(value);
}
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * upload-api
 * Upload API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@upload.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var BASE_PATH = "https://api.upload.io".replace(/\/+$/, "");
var Configuration = /*#__PURE__*/function () {
  function Configuration() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Configuration);
    this.configuration = configuration;
  }
  _createClass(Configuration, [{
    key: "config",
    set: function set(configuration) {
      this.configuration = configuration;
    }
  }, {
    key: "basePath",
    get: function get() {
      return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;
    }
  }, {
    key: "fetchApi",
    get: function get() {
      return this.configuration.fetchApi;
    }
  }, {
    key: "middleware",
    get: function get() {
      return this.configuration.middleware || [];
    }
  }, {
    key: "queryParamsStringify",
    get: function get() {
      return this.configuration.queryParamsStringify || querystring;
    }
  }, {
    key: "username",
    get: function get() {
      return this.configuration.username;
    }
  }, {
    key: "password",
    get: function get() {
      return this.configuration.password;
    }
  }, {
    key: "apiKey",
    get: function get() {
      var apiKey = this.configuration.apiKey;
      if (apiKey) {
        return typeof apiKey === "function" ? apiKey : function (name) {
          return name === "Authorization" ? "Bearer ".concat(apiKey) : apiKey;
        };
      }
      return undefined;
    }
  }, {
    key: "accessToken",
    get: function get() {
      var accessToken = this.configuration.accessToken;
      if (accessToken) {
        return typeof accessToken === "function" ? accessToken : function () {
          return _await(accessToken);
        };
      }
      return undefined;
    }
  }, {
    key: "headers",
    get: function get() {
      return this.configuration.headers;
    }
  }, {
    key: "credentials",
    get: function get() {
      return this.configuration.credentials;
    }
  }]);
  return Configuration;
}();
var DefaultConfig = new Configuration();
/**
 * This is the base class for all generated API classes.
 */
var BaseAPI = /*#__PURE__*/function () {
  function BaseAPI() {
    var _this = this;
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig;
    _classCallCheck(this, BaseAPI);
    this.configuration = configuration;
    this.fetchApi = _async(function (url, init) {
      var fetchParams = {
        url: url,
        init: init
      };
      return _continue(_forOf(_this.middleware, function (middleware) {
        return _invokeIgnored(function () {
          if (middleware.pre) {
            return _await(middleware.pre(Object.assign({
              fetch: _this.fetchApi
            }, fetchParams)), function (_middleware$pre) {
              fetchParams = _middleware$pre || fetchParams;
            });
          }
        });
      }), function () {
        var _exit = false;
        var response = undefined;
        return _continue(_catch(function () {
          return _await((_this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init), function (_temp) {
            response = _temp;
          });
        }, function (e) {
          return _continue(_forOf(_this.middleware, function (middleware) {
            return _invokeIgnored(function () {
              if (middleware.onError) {
                return _await(middleware.onError({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: e,
                  response: response ? response.clone() : undefined
                }), function (_middleware$onError) {
                  response = _middleware$onError || response;
                });
              }
            });
          }), function () {
            if (response === undefined) {
              if (e instanceof Error) {
                throw new FetchError(e, "The request failed and the interceptors did not return an alternative response");
              } else {
                throw e;
              }
            }
          });
        }), function (_result) {
          return _exit ? _result : _continue(_forOf(_this.middleware, function (middleware) {
            return _invokeIgnored(function () {
              if (middleware.post) {
                return _await(middleware.post({
                  fetch: _this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                }), function (_middleware$post) {
                  response = _middleware$post || response;
                });
              }
            });
          }), function () {
            return response;
          });
        });
      });
    });
    this.middleware = configuration.middleware;
  }
  _createClass(BaseAPI, [{
    key: "withMiddleware",
    value: function withMiddleware() {
      var _next$middleware;
      var next = this.clone();
      next.middleware = (_next$middleware = next.middleware).concat.apply(_next$middleware, arguments);
      return next;
    }
  }, {
    key: "withPreMiddleware",
    value: function withPreMiddleware() {
      for (var _len = arguments.length, preMiddlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        preMiddlewares[_key] = arguments[_key];
      }
      var middlewares = preMiddlewares.map(function (pre) {
        return {
          pre: pre
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
  }, {
    key: "withPostMiddleware",
    value: function withPostMiddleware() {
      for (var _len2 = arguments.length, postMiddlewares = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        postMiddlewares[_key2] = arguments[_key2];
      }
      var middlewares = postMiddlewares.map(function (post) {
        return {
          post: post
        };
      });
      return this.withMiddleware.apply(this, _toConsumableArray(middlewares));
    }
  }, {
    key: "request",
    value: function request(context, initOverrides, operationBasePathOverride) {
      try {
        var _this3 = this;
        var _a;
        return _await(_this3.createFetchParams(context, initOverrides, operationBasePathOverride), function (_ref) {
          var url = _ref.url,
            init = _ref.init;
          return _await(_this3.fetchApi(url, init), function (response) {
            var _exit2 = false;
            return response && response.status >= 200 && response.status < 300 ? response : _invoke(function () {
              if (response !== undefined) {
                var jsonError = undefined;
                return _continue(_catch(function () {
                  return _await(response.json(), function (_response$json) {
                    jsonError = _response$json;
                  });
                }, _empty), function () {
                  if (typeof ((_a = jsonError === null || jsonError === void 0 ? void 0 : jsonError.error) === null || _a === void 0 ? void 0 : _a.code) === "string") {
                    throw new UploadApiError(jsonError);
                  }
                });
              }
            }, function (_result2) {
              if (_exit2) return _result2;
              throw new ResponseError(response, "Response returned an error code");
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "createFetchParams",
    value: function createFetchParams(context, initOverrides, operationBasePathOverride) {
      try {
        var _this5 = this;
        var url = (operationBasePathOverride !== null && operationBasePathOverride !== void 0 ? operationBasePathOverride : _this5.configuration.basePath) + context.path;
        if (context.query !== undefined && Object.keys(context.query).length !== 0) {
          // only add the querystring to the URL if there are query parameters.
          // this is done to avoid urls ending with a "?" character which buggy webservers
          // do not handle correctly sometimes.
          url += "?" + _this5.configuration.queryParamsStringify(context.query);
        }
        var headers = Object.assign({}, _this5.configuration.headers, context.headers);
        Object.keys(headers).forEach(function (key) {
          return headers[key] === undefined ? delete headers[key] : {};
        });
        var initOverrideFn = typeof initOverrides === "function" ? initOverrides : function () {
          return _await(initOverrides);
        };
        var initParams = {
          method: context.method,
          headers: headers,
          body: context.body,
          credentials: _this5.configuration.credentials
        };
        var _Object$assign2 = Object.assign({}, initParams);
        return _await(initOverrideFn({
          init: initParams,
          context: context
        }), function (_initOverrideFn) {
          var overriddenInit = Object.assign(_Object$assign2, _initOverrideFn);
          var init = Object.assign(Object.assign({}, overriddenInit), {
            body: isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body) ? overriddenInit.body : JSON.stringify(overriddenInit.body)
          });
          return {
            url: url,
            init: init
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Create a shallow clone of `this` by constructing a new instance
     * and then shallow cloning data members.
     */
  }, {
    key: "clone",
    value: function clone() {
      var constructor = this.constructor;
      var next = new constructor(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    }
  }]);
  return BaseAPI;
}();
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
var UploadApiError = /*#__PURE__*/function (_Error) {
  _inherits(UploadApiError, _Error);
  var _super = _createSuper(UploadApiError);
  function UploadApiError(response) {
    var _this6;
    _classCallCheck(this, UploadApiError);
    _this6 = _super.call(this, response.error.message);
    _this6.name = "UploadApiError";
    _this6.errorCode = response.error.code;
    _this6.details = response.error.details;
    return _this6;
  }
  return _createClass(UploadApiError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var ResponseError = /*#__PURE__*/function (_Error2) {
  _inherits(ResponseError, _Error2);
  var _super2 = _createSuper(ResponseError);
  function ResponseError(response, msg) {
    var _this7;
    _classCallCheck(this, ResponseError);
    _this7 = _super2.call(this, msg);
    _this7.response = response;
    _this7.name = "ResponseError";
    return _this7;
  }
  return _createClass(ResponseError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var FetchError = /*#__PURE__*/function (_Error3) {
  _inherits(FetchError, _Error3);
  var _super3 = _createSuper(FetchError);
  function FetchError(cause, msg) {
    var _this8;
    _classCallCheck(this, FetchError);
    _this8 = _super3.call(this, msg);
    _this8.cause = cause;
    _this8.name = "FetchError";
    return _this8;
  }
  return _createClass(FetchError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var RequiredError = /*#__PURE__*/function (_Error4) {
  _inherits(RequiredError, _Error4);
  var _super4 = _createSuper(RequiredError);
  function RequiredError(field, msg) {
    var _this9;
    _classCallCheck(this, RequiredError);
    _this9 = _super4.call(this, msg);
    _this9.field = field;
    _this9.name = "RequiredError";
    return _this9;
  }
  return _createClass(RequiredError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
var COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|"
};
function querystring(params) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  return Object.keys(params).map(function (key) {
    return querystringSingleKey(key, params[key], prefix);
  }).filter(function (part) {
    return part.length > 0;
  }).join("&");
}
function querystringSingleKey(key, value) {
  var keyPrefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
  var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
  if (value instanceof Array) {
    var multiValue = value.map(function (singleValue) {
      return encodeURIComponent(String(singleValue));
    }).join("&".concat(encodeURIComponent(fullKey), "="));
    return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
  }
  if (value instanceof Set) {
    var valueAsArray = Array.from(value);
    return querystringSingleKey(key, valueAsArray, keyPrefix);
  }
  if (value instanceof Date) {
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value.toISOString()));
  }
  if (value instanceof Object) {
    return querystring(value, fullKey);
  }
  return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value)));
}
function canConsumeForm(consumes) {
  var _iterator = _createForOfIteratorHelper(consumes),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var consume = _step.value;
      if ("multipart/form-data" === consume.contentType) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return false;
}
var JSONApiResponse = /*#__PURE__*/function () {
  function JSONApiResponse(raw) {
    var transformer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function (jsonValue) {
      return jsonValue;
    };
    _classCallCheck(this, JSONApiResponse);
    this.raw = raw;
    this.transformer = transformer;
  }
  _createClass(JSONApiResponse, [{
    key: "value",
    value: function value() {
      try {
        var _this11 = this;
        var _transformer2 = _this11.transformer;
        return _await(_this11.raw.json(), function (_this10$raw$json) {
          return _transformer2.call(_this11, _this10$raw$json);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return JSONApiResponse;
}();
var VoidApiResponse = /*#__PURE__*/function () {
  function VoidApiResponse(raw) {
    _classCallCheck(this, VoidApiResponse);
    this.raw = raw;
  }
  _createClass(VoidApiResponse, [{
    key: "value",
    value: function value() {
      return _await(undefined);
    }
  }]);
  return VoidApiResponse;
}();
var BinaryResult = /*#__PURE__*/function () {
  function BinaryResult(raw) {
    _classCallCheck(this, BinaryResult);
    this.raw = raw;
  }
  _createClass(BinaryResult, [{
    key: "stream",
    value: function stream() {
      if (this.raw.bodyUsed) {
        throw new Error("Response body has already been consumed.");
      }
      if (this.raw.body === null) {
        throw new Error("Response body does not exist.");
      }
      return this.raw.body;
    }
  }, {
    key: "text",
    value: function text() {
      try {
        var _this13 = this;
        return _await(_this13.raw.text());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "blob",
    value: function blob() {
      try {
        var _this15 = this;
        return _await(_this15.raw.blob());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "json",
    value: function json() {
      try {
        var _this17 = this;
        return _await(_this17.raw.json());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return BinaryResult;
}();
var TextApiResponse = /*#__PURE__*/function () {
  function TextApiResponse(raw) {
    _classCallCheck(this, TextApiResponse);
    this.raw = raw;
  }
  _createClass(TextApiResponse, [{
    key: "value",
    value: function value() {
      try {
        var _this19 = this;
        return _await(_this19.raw.text());
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return TextApiResponse;
}();
;// CONCATENATED MODULE: ./src/gen/apis/FileApi.ts
function FileApi_typeof(obj) { "@babel/helpers - typeof"; return FileApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FileApi_typeof(obj); }
function FileApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function FileApi_empty() {}
function _awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(FileApi_empty) : Promise.resolve();
  }
}
function FileApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FileApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, FileApi_toPropertyKey(descriptor.key), descriptor); } }
function FileApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) FileApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) FileApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FileApi_toPropertyKey(arg) { var key = FileApi_toPrimitive(arg, "string"); return FileApi_typeof(key) === "symbol" ? key : String(key); }
function FileApi_toPrimitive(input, hint) { if (FileApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (FileApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function FileApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FileApi_setPrototypeOf(subClass, superClass); }
function FileApi_setPrototypeOf(o, p) { FileApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FileApi_setPrototypeOf(o, p); }
function FileApi_createSuper(Derived) { var hasNativeReflectConstruct = FileApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FileApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FileApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FileApi_possibleConstructorReturn(this, result); }; }
function FileApi_possibleConstructorReturn(self, call) { if (call && (FileApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FileApi_assertThisInitialized(self); }
function FileApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function FileApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function FileApi_getPrototypeOf(o) { FileApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FileApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * upload-api
 * Upload API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@upload.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

/**
 *
 */
var FileApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  FileApi_inherits(FileApi, _runtime$BaseAPI);
  var _super = FileApi_createSuper(FileApi);
  function FileApi() {
    FileApi_classCallCheck(this, FileApi);
    return _super.apply(this, arguments);
  }
  FileApi_createClass(FileApi, [{
    key: "copyFileWithHttpInfo",
    value:
    /**
     * Copies a file synchronously.
     */
    function copyFileWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this2 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling copyFile.");
        }
        if (requestParameters.copyFileRequest === null || requestParameters.copyFileRequest === undefined) {
          throw new RequiredError("copyFileRequest", "Required parameter requestParameters.copyFileRequest was null or undefined when calling copyFile.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this2.configuration && _this2.configuration.apiKey) {
          headerParameters["Authorization"] = _this2.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FileApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/files/copy".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.copyFileRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies a file synchronously.
     */
  }, {
    key: "copyFile",
    value: function copyFile(requestParameters, initOverrides) {
      try {
        var _this4 = this;
        return FileApi_await(_this4.copyFileWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FileApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple files asynchronously.
     */
  }, {
    key: "copyFileBatchWithHttpInfo",
    value: function copyFileBatchWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this6 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling copyFileBatch.");
        }
        if (requestParameters.copyFileBatchRequest === null || requestParameters.copyFileBatchRequest === undefined) {
          throw new RequiredError("copyFileBatchRequest", "Required parameter requestParameters.copyFileBatchRequest was null or undefined when calling copyFileBatch.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this6.configuration && _this6.configuration.apiKey) {
          headerParameters["Authorization"] = _this6.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FileApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/files/copy/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.copyFileBatchRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple files asynchronously.
     */
  }, {
    key: "copyFileBatch",
    value: function copyFileBatch(requestParameters, initOverrides) {
      try {
        var _this8 = this;
        return FileApi_await(_this8.copyFileBatchWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FileApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a file synchronously.
     */
  }, {
    key: "deleteFileWithHttpInfo",
    value: function deleteFileWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this10 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling deleteFile.");
        }
        if (requestParameters.filePath === null || requestParameters.filePath === undefined) {
          throw new RequiredError("filePath", "Required parameter requestParameters.filePath was null or undefined when calling deleteFile.");
        }
        var queryParameters = {};
        if (requestParameters.filePath !== undefined) {
          queryParameters["filePath"] = requestParameters.filePath;
        }
        var headerParameters = {};
        if (_this10.configuration && _this10.configuration.apiKey) {
          headerParameters["Authorization"] = _this10.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FileApi_await(_this10.request({
          path: "/v2/accounts/{accountId}/files".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "DELETE",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new VoidApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a file synchronously.
     */
  }, {
    key: "deleteFile",
    value: function deleteFile(requestParameters, initOverrides) {
      try {
        var _this12 = this;
        return _awaitIgnored(_this12.deleteFileWithHttpInfo(requestParameters, initOverrides));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple files asynchronously.
     */
  }, {
    key: "deleteFileBatchWithHttpInfo",
    value: function deleteFileBatchWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this14 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling deleteFileBatch.");
        }
        if (requestParameters.deleteFileBatchRequest === null || requestParameters.deleteFileBatchRequest === undefined) {
          throw new RequiredError("deleteFileBatchRequest", "Required parameter requestParameters.deleteFileBatchRequest was null or undefined when calling deleteFileBatch.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this14.configuration && _this14.configuration.apiKey) {
          headerParameters["Authorization"] = _this14.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FileApi_await(_this14.request({
          path: "/v2/accounts/{accountId}/files/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "DELETE",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.deleteFileBatchRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple files asynchronously.
     */
  }, {
    key: "deleteFileBatch",
    value: function deleteFileBatch(requestParameters, initOverrides) {
      try {
        var _this16 = this;
        return FileApi_await(_this16.deleteFileBatchWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FileApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Downloads a file in its original/unprocessed state.
     */
  }, {
    key: "downloadFileWithHttpInfo",
    value: function downloadFileWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this18 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling downloadFile.");
        }
        if (requestParameters.filePath === null || requestParameters.filePath === undefined) {
          throw new RequiredError("filePath", "Required parameter requestParameters.filePath was null or undefined when calling downloadFile.");
        }
        var queryParameters = {};
        if (requestParameters.cache !== undefined) {
          queryParameters["cache"] = requestParameters.cache;
        }
        if (requestParameters.cacheTtl !== undefined) {
          queryParameters["cache_ttl"] = requestParameters.cacheTtl;
        }
        if (requestParameters.version !== undefined) {
          queryParameters["version"] = requestParameters.version;
        }
        var headerParameters = {};
        if (_this18.configuration && _this18.configuration.apiKey) {
          headerParameters["Authorization"] = _this18.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = ["https://upcdn.io"][0];
        return FileApi_await(_this18.request({
          path: "/{accountId}/raw{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("filePath", "}"),
          // @ts-ignore
           true ? String(requestParameters.filePath) : 0),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new BinaryResult(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Downloads a file in its original/unprocessed state.
     */
  }, {
    key: "downloadFile",
    value: function downloadFile(requestParameters, initOverrides) {
      try {
        var _this20 = this;
        return FileApi_await(_this20.downloadFileWithHttpInfo(requestParameters, initOverrides));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     */
  }, {
    key: "getFileDetailsWithHttpInfo",
    value: function getFileDetailsWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this22 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling getFileDetails.");
        }
        if (requestParameters.filePath === null || requestParameters.filePath === undefined) {
          throw new RequiredError("filePath", "Required parameter requestParameters.filePath was null or undefined when calling getFileDetails.");
        }
        var queryParameters = {};
        if (requestParameters.filePath !== undefined) {
          queryParameters["filePath"] = requestParameters.filePath;
        }
        var headerParameters = {};
        if (_this22.configuration && _this22.configuration.apiKey) {
          headerParameters["Authorization"] = _this22.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FileApi_await(_this22.request({
          path: "/v2/accounts/{accountId}/files/details".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. metadata, tags, etc.) for a file.
     */
  }, {
    key: "getFileDetails",
    value: function getFileDetails(requestParameters, initOverrides) {
      try {
        var _this24 = this;
        return FileApi_await(_this24.getFileDetailsWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FileApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and returns the result.
     */
  }, {
    key: "processFileWithHttpInfo",
    value: function processFileWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this26 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling processFile.");
        }
        if (requestParameters.filePath === null || requestParameters.filePath === undefined) {
          throw new RequiredError("filePath", "Required parameter requestParameters.filePath was null or undefined when calling processFile.");
        }
        if (requestParameters.transformation === null || requestParameters.transformation === undefined) {
          throw new RequiredError("transformation", "Required parameter requestParameters.transformation was null or undefined when calling processFile.");
        }
        var queryParameters = {};
        if (requestParameters.artifact !== undefined) {
          queryParameters["artifact"] = requestParameters.artifact;
        }
        if (requestParameters.cache !== undefined) {
          queryParameters["cache"] = requestParameters.cache;
        }
        if (requestParameters.cachePerm !== undefined) {
          queryParameters["cache_perm"] = requestParameters.cachePerm;
        }
        if (requestParameters.cacheTtl !== undefined) {
          queryParameters["cache_ttl"] = requestParameters.cacheTtl;
        }
        if (requestParameters.large !== undefined) {
          queryParameters["large"] = requestParameters.large;
        }
        if (requestParameters.version !== undefined) {
          queryParameters["version"] = requestParameters.version;
        }
        var headerParameters = {};
        if (_this26.configuration && _this26.configuration.apiKey) {
          headerParameters["Authorization"] = _this26.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = ["https://upcdn.io"][0];
        return FileApi_await(_this26.request({
          path: "/{accountId}/{transformation}{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("filePath", "}"),
          // @ts-ignore
           true ? String(requestParameters.filePath) : 0).replace("{".concat("transformation", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.transformation))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new BinaryResult(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and returns the result.
     */
  }, {
    key: "processFile",
    value: function processFile(requestParameters, initOverrides) {
      try {
        var _this28 = this;
        return FileApi_await(_this28.processFileWithHttpInfo(requestParameters, initOverrides));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and saves the result.
     */
  }, {
    key: "processFileAndSaveWithHttpInfo",
    value: function processFileAndSaveWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this30 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling processFileAndSave.");
        }
        if (requestParameters.filePath === null || requestParameters.filePath === undefined) {
          throw new RequiredError("filePath", "Required parameter requestParameters.filePath was null or undefined when calling processFileAndSave.");
        }
        if (requestParameters.transformation === null || requestParameters.transformation === undefined) {
          throw new RequiredError("transformation", "Required parameter requestParameters.transformation was null or undefined when calling processFileAndSave.");
        }
        if (requestParameters.processFileAndSaveRequest === null || requestParameters.processFileAndSaveRequest === undefined) {
          throw new RequiredError("processFileAndSaveRequest", "Required parameter requestParameters.processFileAndSaveRequest was null or undefined when calling processFileAndSave.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this30.configuration && _this30.configuration.apiKey) {
          headerParameters["Authorization"] = _this30.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = ["https://upcdn.io"][0];
        return FileApi_await(_this30.request({
          path: "/{accountId}/save/{transformation}{filePath}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("filePath", "}"),
          // @ts-ignore
           true ? String(requestParameters.filePath) : 0).replace("{".concat("transformation", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.transformation))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.processFileAndSaveRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Processes a file and saves the result.
     */
  }, {
    key: "processFileAndSave",
    value: function processFileAndSave(requestParameters, initOverrides) {
      try {
        var _this32 = this;
        return FileApi_await(_this32.processFileAndSaveWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FileApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return FileApi;
}(BaseAPI);
/**
 * @export
 */
var ProcessFileCachePermEnum = {
  Auto: "auto",
  False: "false",
  True: "true"
};
;// CONCATENATED MODULE: ./src/gen/apis/FolderApi.ts
function FolderApi_typeof(obj) { "@babel/helpers - typeof"; return FolderApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FolderApi_typeof(obj); }
function FolderApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function FolderApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FolderApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, FolderApi_toPropertyKey(descriptor.key), descriptor); } }
function FolderApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) FolderApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) FolderApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FolderApi_toPropertyKey(arg) { var key = FolderApi_toPrimitive(arg, "string"); return FolderApi_typeof(key) === "symbol" ? key : String(key); }
function FolderApi_toPrimitive(input, hint) { if (FolderApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (FolderApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function FolderApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FolderApi_setPrototypeOf(subClass, superClass); }
function FolderApi_setPrototypeOf(o, p) { FolderApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FolderApi_setPrototypeOf(o, p); }
function FolderApi_createSuper(Derived) { var hasNativeReflectConstruct = FolderApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FolderApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FolderApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FolderApi_possibleConstructorReturn(this, result); }; }
function FolderApi_possibleConstructorReturn(self, call) { if (call && (FolderApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FolderApi_assertThisInitialized(self); }
function FolderApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function FolderApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function FolderApi_getPrototypeOf(o) { FolderApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FolderApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * upload-api
 * Upload API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@upload.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

/**
 *
 */
var FolderApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  FolderApi_inherits(FolderApi, _runtime$BaseAPI);
  var _super = FolderApi_createSuper(FolderApi);
  function FolderApi() {
    FolderApi_classCallCheck(this, FolderApi);
    return _super.apply(this, arguments);
  }
  FolderApi_createClass(FolderApi, [{
    key: "copyFolderWithHttpInfo",
    value:
    /**
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles```, ```includeOverriddenStorage``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
    function copyFolderWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this2 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling copyFolder.");
        }
        if (requestParameters.copyFolderRequest === null || requestParameters.copyFolderRequest === undefined) {
          throw new RequiredError("copyFolderRequest", "Required parameter requestParameters.copyFolderRequest was null or undefined when calling copyFolder.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this2.configuration && _this2.configuration.apiKey) {
          headerParameters["Authorization"] = _this2.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/folders/copy".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.copyFolderRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies a folder asynchronously.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles```, ```includeOverriddenStorage``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "copyFolder",
    value: function copyFolder(requestParameters, initOverrides) {
      try {
        var _this4 = this;
        return FolderApi_await(_this4.copyFolderWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles```, ```includeOverriddenStorage``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "copyFolderBatchWithHttpInfo",
    value: function copyFolderBatchWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this6 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling copyFolderBatch.");
        }
        if (requestParameters.copyFolderBatchRequest === null || requestParameters.copyFolderBatchRequest === undefined) {
          throw new RequiredError("copyFolderBatchRequest", "Required parameter requestParameters.copyFolderBatchRequest was null or undefined when calling copyFolderBatch.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this6.configuration && _this6.configuration.apiKey) {
          headerParameters["Authorization"] = _this6.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/folders/copy/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.copyFolderBatchRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Copies multiple folders asynchronously.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles```, ```includeOverriddenStorage``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "copyFolderBatch",
    value: function copyFolderBatch(requestParameters, initOverrides) {
      try {
        var _this8 = this;
        return FolderApi_await(_this8.copyFolderBatchWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a folder asynchronously.  If the folder has overridden storage settings, then no files will be deleted.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "deleteFolderWithHttpInfo",
    value: function deleteFolderWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this10 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling deleteFolder.");
        }
        if (requestParameters.deleteFolderRequest === null || requestParameters.deleteFolderRequest === undefined) {
          throw new RequiredError("deleteFolderRequest", "Required parameter requestParameters.deleteFolderRequest was null or undefined when calling deleteFolder.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this10.configuration && _this10.configuration.apiKey) {
          headerParameters["Authorization"] = _this10.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this10.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "DELETE",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.deleteFolderRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes a folder asynchronously.  If the folder has overridden storage settings, then no files will be deleted.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "deleteFolder",
    value: function deleteFolder(requestParameters, initOverrides) {
      try {
        var _this12 = this;
        return FolderApi_await(_this12.deleteFolderWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple folders asynchronously.  If the folder has overridden storage settings, then no files will be deleted.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "deleteFolderBatchWithHttpInfo",
    value: function deleteFolderBatchWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this14 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling deleteFolderBatch.");
        }
        if (requestParameters.deleteFolderBatchRequest === null || requestParameters.deleteFolderBatchRequest === undefined) {
          throw new RequiredError("deleteFolderBatchRequest", "Required parameter requestParameters.deleteFolderBatchRequest was null or undefined when calling deleteFolderBatch.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this14.configuration && _this14.configuration.apiKey) {
          headerParameters["Authorization"] = _this14.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this14.request({
          path: "/v2/accounts/{accountId}/folders/batch".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "DELETE",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.deleteFolderBatchRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Deletes multiple folders asynchronously.  If the folder has overridden storage settings, then no files will be deleted.  You can use ListFolder to preview the operation: set `dryRun=true` with ```recursive```, ```includeFiles``` and ```includeVirtualFolders``` set to match the values you\'re using here. Leave all other flags unset.
     */
  }, {
    key: "deleteFolderBatch",
    value: function deleteFolderBatch(requestParameters, initOverrides) {
      try {
        var _this16 = this;
        return FolderApi_await(_this16.deleteFolderBatchWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.
     */
  }, {
    key: "getFolderDetailsWithHttpInfo",
    value: function getFolderDetailsWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this18 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling getFolderDetails.");
        }
        if (requestParameters.folderPath === null || requestParameters.folderPath === undefined) {
          throw new RequiredError("folderPath", "Required parameter requestParameters.folderPath was null or undefined when calling getFolderDetails.");
        }
        var queryParameters = {};
        if (requestParameters.folderPath !== undefined) {
          queryParameters["folderPath"] = requestParameters.folderPath;
        }
        var headerParameters = {};
        if (_this18.configuration && _this18.configuration.apiKey) {
          headerParameters["Authorization"] = _this18.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this18.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets the full details (e.g. permission, storage layer, etc.) for a folder.  Returns an empty object if no settings have been configured for this folder.
     */
  }, {
    key: "getFolderDetails",
    value: function getFolderDetails(requestParameters, initOverrides) {
      try {
        var _this20 = this;
        return FolderApi_await(_this20.getFolderDetailsWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the folder\'s contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the ```cursor``` request parameter.  Pagination is complete when the response includes `isPaginationComplete=true`.
     */
  }, {
    key: "listFolderWithHttpInfo",
    value: function listFolderWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this22 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling listFolder.");
        }
        if (requestParameters.folderPath === null || requestParameters.folderPath === undefined) {
          throw new RequiredError("folderPath", "Required parameter requestParameters.folderPath was null or undefined when calling listFolder.");
        }
        var queryParameters = {};
        if (requestParameters.cursor !== undefined) {
          queryParameters["cursor"] = requestParameters.cursor;
        }
        if (requestParameters.dryRun !== undefined) {
          queryParameters["dryRun"] = requestParameters.dryRun;
        }
        if (requestParameters.folderPath !== undefined) {
          queryParameters["folderPath"] = requestParameters.folderPath;
        }
        if (requestParameters.includeFiles !== undefined) {
          queryParameters["includeFiles"] = requestParameters.includeFiles;
        }
        if (requestParameters.includeOverriddenStorage !== undefined) {
          queryParameters["includeOverriddenStorage"] = requestParameters.includeOverriddenStorage;
        }
        if (requestParameters.includePhysicalFolders !== undefined) {
          queryParameters["includePhysicalFolders"] = requestParameters.includePhysicalFolders;
        }
        if (requestParameters.includeVirtualFolders !== undefined) {
          queryParameters["includeVirtualFolders"] = requestParameters.includeVirtualFolders;
        }
        if (requestParameters.limit !== undefined) {
          queryParameters["limit"] = requestParameters.limit;
        }
        if (requestParameters.recursive !== undefined) {
          queryParameters["recursive"] = requestParameters.recursive;
        }
        var headerParameters = {};
        if (_this22.configuration && _this22.configuration.apiKey) {
          headerParameters["Authorization"] = _this22.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this22.request({
          path: "/v2/accounts/{accountId}/folders/list".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the folder\'s contents.  The result may be paginated: subsequent pages can be requested by passing the ```cursor``` from the response into the ```cursor``` request parameter.  Pagination is complete when the response includes `isPaginationComplete=true`.
     */
  }, {
    key: "listFolder",
    value: function listFolder(requestParameters, initOverrides) {
      try {
        var _this24 = this;
        return FolderApi_await(_this24.listFolderWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Creates or updates the folder specified by the `folderPath`.  If the folder\'s ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don\'t need to create folders before uploading files to them.
     */
  }, {
    key: "putFolderWithHttpInfo",
    value: function putFolderWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this26 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling putFolder.");
        }
        if (requestParameters.putFolderRequest === null || requestParameters.putFolderRequest === undefined) {
          throw new RequiredError("putFolderRequest", "Required parameter requestParameters.putFolderRequest was null or undefined when calling putFolder.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this26.configuration && _this26.configuration.apiKey) {
          headerParameters["Authorization"] = _this26.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return FolderApi_await(_this26.request({
          path: "/v2/accounts/{accountId}/folders".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "PUT",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.putFolderRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Creates or updates the folder specified by the `folderPath`.  If the folder\'s ancestors do not exist, they will be created automatically (with empty FolderSettings).  Note: you don\'t need to create folders before uploading files to them.
     */
  }, {
    key: "putFolder",
    value: function putFolder(requestParameters, initOverrides) {
      try {
        var _this28 = this;
        return FolderApi_await(_this28.putFolderWithHttpInfo(requestParameters, initOverrides), function (response) {
          return FolderApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return FolderApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/gen/apis/JobApi.ts
function JobApi_typeof(obj) { "@babel/helpers - typeof"; return JobApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, JobApi_typeof(obj); }
function JobApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function JobApi_empty() {}
function JobApi_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(JobApi_empty) : Promise.resolve();
  }
}
function JobApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function JobApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, JobApi_toPropertyKey(descriptor.key), descriptor); } }
function JobApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) JobApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) JobApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function JobApi_toPropertyKey(arg) { var key = JobApi_toPrimitive(arg, "string"); return JobApi_typeof(key) === "symbol" ? key : String(key); }
function JobApi_toPrimitive(input, hint) { if (JobApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (JobApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function JobApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) JobApi_setPrototypeOf(subClass, superClass); }
function JobApi_setPrototypeOf(o, p) { JobApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return JobApi_setPrototypeOf(o, p); }
function JobApi_createSuper(Derived) { var hasNativeReflectConstruct = JobApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = JobApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = JobApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return JobApi_possibleConstructorReturn(this, result); }; }
function JobApi_possibleConstructorReturn(self, call) { if (call && (JobApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return JobApi_assertThisInitialized(self); }
function JobApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function JobApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function JobApi_getPrototypeOf(o) { JobApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return JobApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * upload-api
 * Upload API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@upload.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

/**
 *
 */
var JobApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  JobApi_inherits(JobApi, _runtime$BaseAPI);
  var _super = JobApi_createSuper(JobApi);
  function JobApi() {
    JobApi_classCallCheck(this, JobApi);
    return _super.apply(this, arguments);
  }
  JobApi_createClass(JobApi, [{
    key: "cancelJobWithHttpInfo",
    value:
    /**
     * Cancels an in-progress background job.  Requires a `secret_*` API key.
     */
    function cancelJobWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this2 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling cancelJob.");
        }
        if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
          throw new RequiredError("jobId", "Required parameter requestParameters.jobId was null or undefined when calling cancelJob.");
        }
        if (requestParameters.jobType === null || requestParameters.jobType === undefined) {
          throw new RequiredError("jobType", "Required parameter requestParameters.jobType was null or undefined when calling cancelJob.");
        }
        var queryParameters = {};
        var headerParameters = {};
        if (_this2.configuration && _this2.configuration.apiKey) {
          headerParameters["Authorization"] = _this2.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return JobApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/jobs/{jobType}/{jobId}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("jobId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.jobId))).replace("{".concat("jobType", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.jobType))),
          method: "DELETE",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new VoidApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Cancels an in-progress background job.  Requires a `secret_*` API key.
     */
  }, {
    key: "cancelJob",
    value: function cancelJob(requestParameters, initOverrides) {
      try {
        var _this4 = this;
        return JobApi_awaitIgnored(_this4.cancelJobWithHttpInfo(requestParameters, initOverrides));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets information on a background job.  Requires a `secret_*` API key.
     */
  }, {
    key: "getJobWithHttpInfo",
    value: function getJobWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this6 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling getJob.");
        }
        if (requestParameters.jobId === null || requestParameters.jobId === undefined) {
          throw new RequiredError("jobId", "Required parameter requestParameters.jobId was null or undefined when calling getJob.");
        }
        if (requestParameters.jobType === null || requestParameters.jobType === undefined) {
          throw new RequiredError("jobType", "Required parameter requestParameters.jobType was null or undefined when calling getJob.");
        }
        var queryParameters = {};
        var headerParameters = {};
        if (_this6.configuration && _this6.configuration.apiKey) {
          headerParameters["Authorization"] = _this6.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return JobApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/jobs/{jobType}/{jobId}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("jobId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.jobId))).replace("{".concat("jobType", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.jobType))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets information on a background job.  Requires a `secret_*` API key.
     */
  }, {
    key: "getJob",
    value: function getJob(requestParameters, initOverrides) {
      try {
        var _this8 = this;
        return JobApi_await(_this8.getJobWithHttpInfo(requestParameters, initOverrides), function (response) {
          return JobApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the most recently issued background jobs.  Requires a `secret_*` API key.
     */
  }, {
    key: "listRecentJobsWithHttpInfo",
    value: function listRecentJobsWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this10 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling listRecentJobs.");
        }
        if (requestParameters.jobType === null || requestParameters.jobType === undefined) {
          throw new RequiredError("jobType", "Required parameter requestParameters.jobType was null or undefined when calling listRecentJobs.");
        }
        var queryParameters = {};
        if (requestParameters.jobType) {
          queryParameters["jobType"] = requestParameters.jobType;
        }
        var headerParameters = {};
        if (_this10.configuration && _this10.configuration.apiKey) {
          headerParameters["Authorization"] = _this10.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return JobApi_await(_this10.request({
          path: "/v2/accounts/{accountId}/jobs".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the most recently issued background jobs.  Requires a `secret_*` API key.
     */
  }, {
    key: "listRecentJobs",
    value: function listRecentJobs(requestParameters, initOverrides) {
      try {
        var _this12 = this;
        return JobApi_await(_this12.listRecentJobsWithHttpInfo(requestParameters, initOverrides), function (response) {
          return JobApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return JobApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/gen/apis/UploadApi.ts
function UploadApi_typeof(obj) { "@babel/helpers - typeof"; return UploadApi_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UploadApi_typeof(obj); }
function UploadApi_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadApi_empty() {}
function UploadApi_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(UploadApi_empty) : Promise.resolve();
  }
}
function UploadApi_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadApi_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadApi_toPropertyKey(descriptor.key), descriptor); } }
function UploadApi_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadApi_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadApi_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadApi_toPropertyKey(arg) { var key = UploadApi_toPrimitive(arg, "string"); return UploadApi_typeof(key) === "symbol" ? key : String(key); }
function UploadApi_toPrimitive(input, hint) { if (UploadApi_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UploadApi_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function UploadApi_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) UploadApi_setPrototypeOf(subClass, superClass); }
function UploadApi_setPrototypeOf(o, p) { UploadApi_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return UploadApi_setPrototypeOf(o, p); }
function UploadApi_createSuper(Derived) { var hasNativeReflectConstruct = UploadApi_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = UploadApi_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = UploadApi_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return UploadApi_possibleConstructorReturn(this, result); }; }
function UploadApi_possibleConstructorReturn(self, call) { if (call && (UploadApi_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return UploadApi_assertThisInitialized(self); }
function UploadApi_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function UploadApi_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function UploadApi_getPrototypeOf(o) { UploadApi_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return UploadApi_getPrototypeOf(o); }
/* tslint:disable */
/* eslint-disable */
/**
 * upload-api
 * Upload API
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: hello@upload.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore

/**
 *
 */
var UploadApi = /*#__PURE__*/function (_runtime$BaseAPI) {
  UploadApi_inherits(UploadApi, _runtime$BaseAPI);
  var _super = UploadApi_createSuper(UploadApi);
  function UploadApi() {
    UploadApi_classCallCheck(this, UploadApi);
    return _super.apply(this, arguments);
  }
  UploadApi_createClass(UploadApi, [{
    key: "beginMultipartUploadWithHttpInfo",
    value:
    /**
     * Begins a new multipart file upload process.
     */
    function beginMultipartUploadWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this2 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling beginMultipartUpload.");
        }
        if (requestParameters.beginMultipartUploadRequest === null || requestParameters.beginMultipartUploadRequest === undefined) {
          throw new RequiredError("beginMultipartUploadRequest", "Required parameter requestParameters.beginMultipartUploadRequest was null or undefined when calling beginMultipartUpload.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this2.configuration && _this2.configuration.apiKey) {
          headerParameters["Authorization"] = _this2.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return UploadApi_await(_this2.request({
          path: "/v2/accounts/{accountId}/uploads".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.beginMultipartUploadRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Begins a new multipart file upload process.
     */
  }, {
    key: "beginMultipartUpload",
    value: function beginMultipartUpload(requestParameters, initOverrides) {
      try {
        var _this4 = this;
        return UploadApi_await(_this4.beginMultipartUploadWithHttpInfo(requestParameters, initOverrides), function (response) {
          return UploadApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Marks an upload part as uploaded.  You must call this endpoint after you have successfully issued a `PUT` request to the `uploadUrl` on the corresponding UploadPart.
     */
  }, {
    key: "completeUploadPartWithHttpInfo",
    value: function completeUploadPartWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this6 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling completeUploadPart.");
        }
        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
          throw new RequiredError("uploadId", "Required parameter requestParameters.uploadId was null or undefined when calling completeUploadPart.");
        }
        if (requestParameters.uploadPartIndex === null || requestParameters.uploadPartIndex === undefined) {
          throw new RequiredError("uploadPartIndex", "Required parameter requestParameters.uploadPartIndex was null or undefined when calling completeUploadPart.");
        }
        if (requestParameters.completeUploadPartRequest === null || requestParameters.completeUploadPartRequest === undefined) {
          throw new RequiredError("completeUploadPartRequest", "Required parameter requestParameters.completeUploadPartRequest was null or undefined when calling completeUploadPart.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this6.configuration && _this6.configuration.apiKey) {
          headerParameters["Authorization"] = _this6.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return UploadApi_await(_this6.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts/{uploadPartIndex}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("uploadId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.uploadId))).replace("{".concat("uploadPartIndex", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.uploadPartIndex))),
          method: "PUT",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.completeUploadPartRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new VoidApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Marks an upload part as uploaded.  You must call this endpoint after you have successfully issued a `PUT` request to the `uploadUrl` on the corresponding UploadPart.
     */
  }, {
    key: "completeUploadPart",
    value: function completeUploadPart(requestParameters, initOverrides) {
      try {
        var _this8 = this;
        return UploadApi_awaitIgnored(_this8.completeUploadPartWithHttpInfo(requestParameters, initOverrides));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets a remaining upload part for a multipart file upload.
     */
  }, {
    key: "getUploadPartWithHttpInfo",
    value: function getUploadPartWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this10 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling getUploadPart.");
        }
        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
          throw new RequiredError("uploadId", "Required parameter requestParameters.uploadId was null or undefined when calling getUploadPart.");
        }
        if (requestParameters.uploadPartIndex === null || requestParameters.uploadPartIndex === undefined) {
          throw new RequiredError("uploadPartIndex", "Required parameter requestParameters.uploadPartIndex was null or undefined when calling getUploadPart.");
        }
        var queryParameters = {};
        var headerParameters = {};
        if (_this10.configuration && _this10.configuration.apiKey) {
          headerParameters["Authorization"] = _this10.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return UploadApi_await(_this10.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts/{uploadPartIndex}".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("uploadId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.uploadId))).replace("{".concat("uploadPartIndex", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.uploadPartIndex))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Gets a remaining upload part for a multipart file upload.
     */
  }, {
    key: "getUploadPart",
    value: function getUploadPart(requestParameters, initOverrides) {
      try {
        var _this12 = this;
        return UploadApi_await(_this12.getUploadPartWithHttpInfo(requestParameters, initOverrides), function (response) {
          return UploadApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the remaining upload parts for a multipart file upload.  An empty array is returned when the upload is complete.
     */
  }, {
    key: "listUploadPartsWithHttpInfo",
    value: function listUploadPartsWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this14 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling listUploadParts.");
        }
        if (requestParameters.uploadId === null || requestParameters.uploadId === undefined) {
          throw new RequiredError("uploadId", "Required parameter requestParameters.uploadId was null or undefined when calling listUploadParts.");
        }
        var queryParameters = {};
        var headerParameters = {};
        if (_this14.configuration && _this14.configuration.apiKey) {
          headerParameters["Authorization"] = _this14.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return UploadApi_await(_this14.request({
          path: "/v2/accounts/{accountId}/uploads/{uploadId}/parts".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))).replace("{".concat("uploadId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.uploadId))),
          method: "GET",
          headers: headerParameters,
          query: queryParameters
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Lists the remaining upload parts for a multipart file upload.  An empty array is returned when the upload is complete.
     */
  }, {
    key: "listUploadParts",
    value: function listUploadParts(requestParameters, initOverrides) {
      try {
        var _this16 = this;
        return UploadApi_await(_this16.listUploadPartsWithHttpInfo(requestParameters, initOverrides), function (response) {
          return UploadApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Upload from a URL with a single HTTP request:
     */
  }, {
    key: "uploadFromUrlWithHttpInfo",
    value: function uploadFromUrlWithHttpInfo(requestParameters, initOverrides) {
      try {
        var _this18 = this;
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
          throw new RequiredError("accountId", "Required parameter requestParameters.accountId was null or undefined when calling uploadFromUrl.");
        }
        if (requestParameters.uploadFromUrlRequest === null || requestParameters.uploadFromUrlRequest === undefined) {
          throw new RequiredError("uploadFromUrlRequest", "Required parameter requestParameters.uploadFromUrlRequest was null or undefined when calling uploadFromUrl.");
        }
        var queryParameters = {};
        var headerParameters = {};
        headerParameters["Content-Type"] = "application/json";
        if (_this18.configuration && _this18.configuration.apiKey) {
          headerParameters["Authorization"] = _this18.configuration.apiKey("Authorization"); // authorization-header authentication
        }

        var operationBasePathOverride = [][0];
        return UploadApi_await(_this18.request({
          path: "/v2/accounts/{accountId}/uploads/url".replace("{".concat("accountId", "}"),
          // @ts-ignore
           false ? 0 : encodeURIComponent(String(requestParameters.accountId))),
          method: "POST",
          headers: headerParameters,
          query: queryParameters,
          body: requestParameters.uploadFromUrlRequest
        }, initOverrides, operationBasePathOverride), function (response) {
          return new JSONApiResponse(response);
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Upload from a URL with a single HTTP request:
     */
  }, {
    key: "uploadFromUrl",
    value: function uploadFromUrl(requestParameters, initOverrides) {
      try {
        var _this20 = this;
        return UploadApi_await(_this20.uploadFromUrlWithHttpInfo(requestParameters, initOverrides), function (response) {
          return UploadApi_await(response.value());
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return UploadApi;
}(BaseAPI);
;// CONCATENATED MODULE: ./src/gen/apis/index.ts
/* tslint:disable */
/* eslint-disable */




;// CONCATENATED MODULE: ./src/gen/models/index.ts
/* tslint:disable */
/* eslint-disable */
/**
 * "Created" is only used when issuing jobs non-transactionally (which we do if we want the job to be picked up sooner).
 * In this case, a two-phase transaction is performed.
 *
 * T=0) "Created" job tracker created.
 * T=1) SQS job enqueued.
 * T=2) "Pending" is set into job tracker.
 * T=3) Response returned to use
 * T=4) SQS picks up job. If status is "Created" it fails the job attempt. This keeps going until eventually the job perm-fails, or it sees "Pending". It should typically (always?) see "Pending" on the first attempt, if T=2 succeeded.
 * T=5) SQS processes the job as normal.
 *
 * As such, the "Created" state is an internal detail, and we never expose jobs in this state to the user.
 * @export
 */
var AccountJobStatus = {
  Created: "Created",
  Pending: "Pending",
  Running: "Running",
  Rollback: "Rollback",
  Failed: "Failed",
  Succeeded: "Succeeded",
  Cancelling: "Cancelling",
  Cancelled: "Cancelled"
};
/**
 * Job type.
 * @export
 */
var AccountJobType = {
  DeleteFolderBatchJob: "DeleteFolderBatchJob",
  DeleteFileBatchJob: "DeleteFileBatchJob",
  CopyFolderBatchJob: "CopyFolderBatchJob",
  CopyFileBatchJob: "CopyFileBatchJob"
};
/**
 * @export
 */
var AsyncResponseJobDocsEnum = {
  HttpsUploadIoDocsUploadApiJobsGetJob: "https://upload.io/docs/upload-api/jobs/GetJob"
};
/**
 * AWS Region.
 * @export
 */
var AwsRegion = {
  UsEast2: "us-east-2",
  UsEast1: "us-east-1",
  UsWest1: "us-west-1",
  UsWest2: "us-west-2",
  AfSouth1: "af-south-1",
  ApEast1: "ap-east-1",
  ApSoutheast3: "ap-southeast-3",
  ApSouth1: "ap-south-1",
  ApNortheast3: "ap-northeast-3",
  ApNortheast2: "ap-northeast-2",
  ApSoutheast1: "ap-southeast-1",
  ApSoutheast2: "ap-southeast-2",
  ApNortheast1: "ap-northeast-1",
  CaCentral1: "ca-central-1",
  EuCentral1: "eu-central-1",
  EuWest1: "eu-west-1",
  EuWest2: "eu-west-2",
  EuSouth1: "eu-south-1",
  EuWest3: "eu-west-3",
  EuNorth1: "eu-north-1",
  MeSouth1: "me-south-1",
  SaEast1: "sa-east-1"
};
/**
 * The result of the CopyFile operation.
 * @export
 */
var FileCopyStatus = {
  Copied: "Copied",
  FileNotFound: "FileNotFound",
  SkippedDueToCondition: "SkippedDueToCondition"
};
/**
 * @export
 */
var FileSummaryTypeEnum = {
  File: "File"
};
/**
 * @export
 */
var FolderDetailsTypeEnum = {
  Folder: "Folder"
};
/**
 * @export
 */
var FolderSettingsStorageLayerSummaryStorageLayerTypeEnum = {
  S3: "S3"
};
/**
 * @export
 */
var FolderSummaryTypeEnum = {
  Folder: "Folder"
};
/**
 * @export
 */
var InternalStorageV1TypeEnum = {
  InternalStorageV1: "InternalStorageV1"
};
/**
 * @export
 */
var InternalStorageV2TypeEnum = {
  InternalStorageV2: "InternalStorageV2"
};
/**
 * Multipart file upload protocol version.
 *
 * - `1.0`: this protocol version automatically downgrades to single part uploads when files are below a certain size. When this protocol is used for small files, the file exists immediately after the `PUT` request to the `uploadUrl` completes. This protocol requires more client-side code to implement, and has a known issue whereby file TTLs are ignored if the client code fails to call CompleteUploadPart.
 *
 * - `1.1`: this protocol version uses multipart uploads for all files. When this protocol is used, files only exist after the last CompleteUploadPart request is made. This protocol simplifies client code, and fixes a known issue in the `2.0` protocol for file TTLs (described above).
 * @export
 */
var MultipartUploadProtocol = {
  _0: "1.0",
  _1: "1.1"
};
/**
 * @export
 */
var ObjectSummaryTypeEnum = {
  File: "File"
};
/**
 * Specifies the level in the file tree, relative to the path, that these permissions apply.
 *
 * - `"This"`: Permissions apply to the current path only.
 *
 * - `"Children"`: Permissions apply to the children (files and folders) of this path only.
 *
 * - `"Grandchildren+"`: Permissions apply to the grandchildren (files and folders) of this path and their descendants only.
 * @export
 */
var PathPermissionScope = {
  Children: "Children",
  Grandchildren: "Grandchildren+",
  This: "This"
};
/**
 * @export
 */
var PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum = {
  S3: "S3"
};
/**
 * @export
 */
var S3StorageTypeEnum = {
  S3: "S3"
};
/**
 * @export
 */
var SpecifiedFieldValueFolderDescriptionOrNullSetEnum = {
  True: true
};
/**
 * @export
 */
var SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum = {
  True: true
};
/**
 * @export
 */
var SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum = {
  True: true
};
/**
 * @export
 */
var SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum = {
  S3: "S3"
};
/**
 * @export
 */
var StorageLayerSummaryTypeEnum = {
  S3: "S3"
};
/**
 * @export
 */
var StorageLayerUpdateTypeEnum = {
  S3: "S3"
};
/**
 * @export
 */
var TagConditionTypeEnum = {
  All: "All"
};
/**
 * @export
 */
var TagConditionAllTypeEnum = {
  All: "All"
};
/**
 * @export
 */
var TagConditionAndTypeEnum = {
  And: "And"
};
/**
 * @export
 */
var TagConditionAnyTypeEnum = {
  Any: "Any"
};
/**
 * @export
 */
var TagConditionEqualsTypeEnum = {
  Equals: "Equals"
};
/**
 * @export
 */
var TagConditionNotTypeEnum = {
  Not: "Not"
};
/**
 * @export
 */
var TagConditionOrTypeEnum = {
  Or: "Or"
};
/**
 * @export
 */
var UnspecifiedFieldValueSetEnum = {
  False: false
};
/**
 * @export
 */
var UpdatableFieldFolderDescriptionOrNullSetEnum = {
  True: true
};
/**
 * @export
 */
var UpdatableFieldPublicPermissionsArrayOrNullSetEnum = {
  True: true
};
/**
 * @export
 */
var UpdatableFieldStorageLayerUpdateOrNullSetEnum = {
  True: true
};
/**
 * @export
 */
var WebStorageTypeEnum = {
  Web: "Web"
};
;// CONCATENATED MODULE: ./src/gen/index.ts
/* tslint:disable */
/* eslint-disable */



;// CONCATENATED MODULE: ./src/utils/ChunkedStream.ts
function ChunkedStream_typeof(obj) { "@babel/helpers - typeof"; return ChunkedStream_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ChunkedStream_typeof(obj); }
function ChunkedStream_invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || ChunkedStream_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function ChunkedStream_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ChunkedStream_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ChunkedStream_arrayLikeToArray(o, minLen); }
function ChunkedStream_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ChunkedStream_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function ChunkedStream_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function ChunkedStream_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, ChunkedStream_toPropertyKey(descriptor.key), descriptor); } }
function ChunkedStream_createClass(Constructor, protoProps, staticProps) { if (protoProps) ChunkedStream_defineProperties(Constructor.prototype, protoProps); if (staticProps) ChunkedStream_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function ChunkedStream_toPropertyKey(arg) { var key = ChunkedStream_toPrimitive(arg, "string"); return ChunkedStream_typeof(key) === "symbol" ? key : String(key); }
function ChunkedStream_toPrimitive(input, hint) { if (ChunkedStream_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (ChunkedStream_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
var ChunkedStream = /*#__PURE__*/function () {
  function ChunkedStream(source) {
    ChunkedStream_classCallCheck(this, ChunkedStream);
    this.source = source;
    this.buffer = Buffer.alloc(0);
    this.isSourceFullyConsumed = false; // true if the source stream indicates it has finished.
    this.isFinishedConsuming = false; // true if _we_ indicate we have finished reading all we want from the stream.
    this.resolver = undefined;
  }
  /**
   * If the source stream is larger than the 'size' the user is consuming (i.e. they're only wanting to upload a subset
   * of the stream) then the stream won't be resolved by the 'end' event inside 'runChunkPipeline', so calling this
   * method is necessary.
   */
  ChunkedStream_createClass(ChunkedStream, [{
    key: "finishedConsuming",
    value: function finishedConsuming() {
      this.isFinishedConsuming = true;
      if (this.resolver !== undefined) {
        this.resolver();
      }
    }
    /**
     * Promise resolves when the entire stream has finished processing, or an error occurs.
     * You must call 'take' a sufficient number of times after calling this method in order for this promise to resolve.
     */
  }, {
    key: "runChunkPipeline",
    value: function runChunkPipeline() {
      try {
        var _this2 = this;
        return ChunkedStream_await(new Promise(function (resolve, reject) {
          _this2.resolver = resolve;
          var onError = function onError(error) {
            removeListeners();
            reject(error);
          };
          var onEnd = function onEnd() {
            _this2.isSourceFullyConsumed = true;
            removeListeners();
            resolve();
          };
          var onData = function onData(buffer) {
            try {
              if (_this2.isFinishedConsuming) {
                return;
              }
              if (_this2.consumer === undefined) {
                console.warn("Stream yielded data while paused. The data will be buffered, but excessive buffering can cause memory issues.");
                _this2.buffer = Buffer.concat([_this2.buffer, buffer]);
                return;
              }
              if (_this2.consumer.bytesRemaining <= 0) {
                throw new Error("Consumer requires zero bytes, so should not be consuming from the stream.");
              }
              if (_this2.buffer.byteLength > 0) {
                throw new Error("Buffer was expected to be empty (as it should have been flushed to the consumer when '.take' was called).");
              }
              var splitResult = _this2.splitBuffer(buffer, _this2.consumer.bytesRemaining);
              if (splitResult === undefined) {
                return; // Received empty data.
              }

              var _splitResult = _slicedToArray(splitResult, 2),
                consumed = _splitResult[0],
                remaining = _splitResult[1];
              _this2.buffer = remaining;
              _this2.consumer.bytesRemaining -= consumed.byteLength;
              _this2.consumer.stream.push(consumed);
              if (_this2.consumer.bytesRemaining === 0) {
                _this2.finishStream(_this2.consumer.stream);
                _this2.consumer = undefined;
                _this2.source.pause();
              }
            } catch (e) {
              removeListeners();
              reject(e);
            }
          };
          var removeListeners = function removeListeners() {
            _this2.source.removeListener("data", onData);
            _this2.source.removeListener("error", onError);
            _this2.source.removeListener("end", onEnd);
          };
          _this2.source.on("data", onData);
          _this2.source.on("error", onError);
          _this2.source.on("end", onEnd);
          _this2.source.pause(); // Resumed when 'take' is called.
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Only call 'take' after the previously returned stream has been fully consumed.
     */
  }, {
    key: "take",
    value: function take(bytes) {
      try {
        var _exit2 = false;
        var _this4 = this;
        var _a;
        if (_this4.consumer !== undefined) {
          throw new Error("The stream from the previous 'take' call must be fully consumed before calling 'take' again.");
        }
        return ChunkedStream_invoke(function () {
          if (bytes <= 0) {
            _exit2 = true;
            return ChunkedStream_await(_this4.emptyStream());
          }
        }, function (_result) {
          return _exit2 ? _result : ChunkedStream_await(_this4.createStream(), function (readable) {
            var consumedFromBuffer = _this4.consumeFromBuffer(bytes);
            var consumedFromBufferLength = (_a = consumedFromBuffer === null || consumedFromBuffer === void 0 ? void 0 : consumedFromBuffer.length) !== null && _a !== void 0 ? _a : 0;
            var bytesToConsumeFromStream = bytes - consumedFromBufferLength;
            if (consumedFromBuffer !== undefined) {
              readable.push(consumedFromBuffer);
            }
            if (bytesToConsumeFromStream > 0) {
              if (_this4.isSourceFullyConsumed) {
                throw new Error("Stream finished processing earlier than expected. The \"size\" parameter is likely larger than the stream's actual contents.");
              }
              _this4.consumer = {
                bytesRemaining: bytesToConsumeFromStream,
                stream: readable
              };
              _this4.source.resume();
            } else {
              _this4.finishStream(readable);
            }
            return readable;
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "consumeFromBuffer",
    value: function consumeFromBuffer(bytes) {
      var splitResult = this.splitBuffer(this.buffer, bytes);
      if (splitResult === undefined) {
        return undefined;
      }
      var _splitResult2 = _slicedToArray(splitResult, 2),
        consumed = _splitResult2[0],
        remaining = _splitResult2[1];
      this.buffer = remaining;
      return consumed;
    }
  }, {
    key: "splitBuffer",
    value: function splitBuffer(buffer, maxBytes) {
      if (buffer.byteLength === 0) {
        return undefined;
      }
      var bytesToConsume = Math.min(maxBytes, buffer.byteLength);
      if (bytesToConsume === buffer.byteLength) {
        return [buffer, Buffer.alloc(0)]; // Optimization
      }

      var consumed = buffer.subarray(0, bytesToConsume);
      var remaining = buffer.subarray(bytesToConsume);
      return [consumed, remaining];
    }
  }, {
    key: "createStream",
    value: function createStream() {
      try {
        // We import "stream" lazily to support browsers, which don't have this module, but also won't call this method so won't trigger the import.
        return ChunkedStream_await(Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, "stream")), function (_import) {
          var streamModule = _import["default"];
          var Readable = streamModule.Readable;
          var readable = new Readable();
          readable._read = function () {}; // _read is required but you can noop it
          return readable;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "emptyStream",
    value: function emptyStream() {
      try {
        var _this6 = this;
        return ChunkedStream_await(_this6.createStream(), function (readable) {
          _this6.finishStream(readable);
          return readable;
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "finishStream",
    value: function finishStream(readable) {
      readable.push(null);
    }
  }]);
  return ChunkedStream;
}();
;// CONCATENATED MODULE: ./src/utils/Model.ts
function Model_typeof(obj) { "@babel/helpers - typeof"; return Model_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Model_typeof(obj); }
function Model_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, Model_toPropertyKey(descriptor.key), descriptor); } }
function Model_createClass(Constructor, protoProps, staticProps) { if (protoProps) Model_defineProperties(Constructor.prototype, protoProps); if (staticProps) Model_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function Model_toPropertyKey(arg) { var key = Model_toPrimitive(arg, "string"); return Model_typeof(key) === "symbol" ? key : String(key); }
function Model_toPrimitive(input, hint) { if (Model_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (Model_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function Model_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function Model_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Model_setPrototypeOf(subClass, superClass); }
function Model_createSuper(Derived) { var hasNativeReflectConstruct = Model_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Model_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Model_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Model_possibleConstructorReturn(this, result); }; }
function Model_possibleConstructorReturn(self, call) { if (call && (Model_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Model_assertThisInitialized(self); }
function Model_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function Model_wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; Model_wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !Model_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return Model_construct(Class, arguments, Model_getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return Model_setPrototypeOf(Wrapper, Class); }; return Model_wrapNativeSuper(Class); }
function Model_construct(Parent, args, Class) { if (Model_isNativeReflectConstruct()) { Model_construct = Reflect.construct.bind(); } else { Model_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) Model_setPrototypeOf(instance, Class.prototype); return instance; }; } return Model_construct.apply(null, arguments); }
function Model_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function Model_isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }
function Model_setPrototypeOf(o, p) { Model_setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Model_setPrototypeOf(o, p); }
function Model_getPrototypeOf(o) { Model_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Model_getPrototypeOf(o); }
var CancelledError = /*#__PURE__*/function (_Error) {
  Model_inherits(CancelledError, _Error);
  var _super = Model_createSuper(CancelledError);
  function CancelledError(msg) {
    var _this;
    Model_classCallCheck(this, CancelledError);
    _this = _super.call(this, msg);
    _this.msg = msg;
    _this.name = "CancelledError";
    return _this;
  }
  return Model_createClass(CancelledError);
}( /*#__PURE__*/Model_wrapNativeSuper(Error));
// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__("stream");
;// CONCATENATED MODULE: ./src/utils/UploadManager.ts
function UploadManager_typeof(obj) { "@babel/helpers - typeof"; return UploadManager_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, UploadManager_typeof(obj); }
function UploadManager_async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function UploadManager_empty() {}
function UploadManager_awaitIgnored(value, direct) {
  if (!direct) {
    return value && value.then ? value.then(UploadManager_empty) : Promise.resolve();
  }
}
function UploadManager_invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function UploadManager_invokeIgnored(body) {
  var result = body();
  if (result && result.then) {
    return result.then(UploadManager_empty);
  }
}
function UploadManager_settle(pact, state, value) {
  if (!pact.s) {
    if (value instanceof UploadManager_Pact) {
      if (value.s) {
        if (state & 1) {
          state = value.s;
        }
        value = value.v;
      } else {
        value.o = UploadManager_settle.bind(null, pact, state);
        return;
      }
    }
    if (value && value.then) {
      value.then(UploadManager_settle.bind(null, pact, state), UploadManager_settle.bind(null, pact, 2));
      return;
    }
    pact.s = state;
    pact.v = value;
    var observer = pact.o;
    if (observer) {
      observer(pact);
    }
  }
}
var UploadManager_Pact = /*#__PURE__*/function () {
  function _Pact() {}
  _Pact.prototype.then = function (onFulfilled, onRejected) {
    var result = new _Pact();
    var state = this.s;
    if (state) {
      var callback = state & 1 ? onFulfilled : onRejected;
      if (callback) {
        try {
          UploadManager_settle(result, 1, callback(this.v));
        } catch (e) {
          UploadManager_settle(result, 2, e);
        }
        return result;
      } else {
        return this;
      }
    }
    this.o = function (_this) {
      try {
        var value = _this.v;
        if (_this.s & 1) {
          UploadManager_settle(result, 1, onFulfilled ? onFulfilled(value) : value);
        } else if (onRejected) {
          UploadManager_settle(result, 1, onRejected(value));
        } else {
          UploadManager_settle(result, 2, value);
        }
      } catch (e) {
        UploadManager_settle(result, 2, e);
      }
    };
    return result;
  };
  return _Pact;
}();
function UploadManager_isSettledPact(thenable) {
  return thenable instanceof UploadManager_Pact && thenable.s & 1;
}
function _for(test, update, body) {
  var stage;
  for (;;) {
    var shouldContinue = test();
    if (UploadManager_isSettledPact(shouldContinue)) {
      shouldContinue = shouldContinue.v;
    }
    if (!shouldContinue) {
      return result;
    }
    if (shouldContinue.then) {
      stage = 0;
      break;
    }
    var result = body();
    if (result && result.then) {
      if (UploadManager_isSettledPact(result)) {
        result = result.s;
      } else {
        stage = 1;
        break;
      }
    }
    if (update) {
      var updateValue = update();
      if (updateValue && updateValue.then && !UploadManager_isSettledPact(updateValue)) {
        stage = 2;
        break;
      }
    }
  }
  var pact = new UploadManager_Pact();
  var reject = UploadManager_settle.bind(null, pact, 2);
  (stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);
  return pact;
  function _resumeAfterBody(value) {
    result = value;
    do {
      if (update) {
        updateValue = update();
        if (updateValue && updateValue.then && !UploadManager_isSettledPact(updateValue)) {
          updateValue.then(_resumeAfterUpdate).then(void 0, reject);
          return;
        }
      }
      shouldContinue = test();
      if (!shouldContinue || UploadManager_isSettledPact(shouldContinue) && !shouldContinue.v) {
        UploadManager_settle(pact, 1, result);
        return;
      }
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
        return;
      }
      result = body();
      if (UploadManager_isSettledPact(result)) {
        result = result.v;
      }
    } while (!result || !result.then);
    result.then(_resumeAfterBody).then(void 0, reject);
  }
  function _resumeAfterTest(shouldContinue) {
    if (shouldContinue) {
      result = body();
      if (result && result.then) {
        result.then(_resumeAfterBody).then(void 0, reject);
      } else {
        _resumeAfterBody(result);
      }
    } else {
      UploadManager_settle(pact, 1, result);
    }
  }
  function _resumeAfterUpdate() {
    if (shouldContinue = test()) {
      if (shouldContinue.then) {
        shouldContinue.then(_resumeAfterTest).then(void 0, reject);
      } else {
        _resumeAfterTest(shouldContinue);
      }
    } else {
      UploadManager_settle(pact, 1, result);
    }
  }
}
function _continueIgnored(value) {
  if (value && value.then) {
    return value.then(UploadManager_empty);
  }
}
function UploadManager_toConsumableArray(arr) { return UploadManager_arrayWithoutHoles(arr) || UploadManager_iterableToArray(arr) || UploadManager_unsupportedIterableToArray(arr) || UploadManager_nonIterableSpread(); }
function UploadManager_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function UploadManager_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return UploadManager_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return UploadManager_arrayLikeToArray(o, minLen); }
function UploadManager_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function UploadManager_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return UploadManager_arrayLikeToArray(arr); }
function UploadManager_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function UploadManager_await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }
  if (!value || !value.then) {
    value = Promise.resolve(value);
  }
  return then ? value.then(then) : value;
}
function UploadManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function UploadManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, UploadManager_toPropertyKey(descriptor.key), descriptor); } }
function UploadManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) UploadManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) UploadManager_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function UploadManager_toPropertyKey(arg) { var key = UploadManager_toPrimitive(arg, "string"); return UploadManager_typeof(key) === "symbol" ? key : String(key); }
function UploadManager_toPrimitive(input, hint) { if (UploadManager_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (UploadManager_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }




var UploadManager = /*#__PURE__*/function () {
  function UploadManager() {
    var configuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DefaultConfig;
    UploadManager_classCallCheck(this, UploadManager);
    this.configuration = configuration;
    this.stringMimeType = "text/plain";
    this.defaultMaxConcurrentUploadParts = 4;
    this.uploadApi = new UploadApi(configuration);
  }
  UploadManager_createClass(UploadManager, [{
    key: "upload",
    value: function upload(request) {
      try {
        var _this2 = this;
        return UploadManager_await(_this2.processUploadSource(request.data), function (data) {
          var chunkedStream = _this2.getChunkedStream(data);
          return UploadManager_await(_this2.beginUpload(request, data), function (uploadInfo) {
            _this2.checkIfCancelled(request);
            var maxConcurrency = _this2.calculateMaxConcurrency(request, data);
            var partCount = uploadInfo.uploadParts.count;
            var parts = UploadManager_toConsumableArray(Array(partCount).keys());
            var runSourceStreamPump = chunkedStream === null || chunkedStream === void 0 ? void 0 : chunkedStream.runChunkPipeline();
            return UploadManager_await(_this2.mapAsync(parts, maxConcurrency, UploadManager_async(function (part) {
              return _this2.uploadPart(request, data, part, uploadInfo);
            })), function () {
              if (chunkedStream !== undefined) {
                chunkedStream.finishedConsuming();
              }
              return UploadManager_await(runSourceStreamPump, function () {
                return uploadInfo.file;
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "checkIfCancelled",
    value: function checkIfCancelled(request) {
      var _a;
      if (((_a = request.cancellationToken) === null || _a === void 0 ? void 0 : _a.isCancelled) === true) {
        throw new CancelledError("Upload cancelled by user.");
      }
    }
  }, {
    key: "beginUpload",
    value: function beginUpload(request, data) {
      try {
        var _this4 = this;
        var size = _this4.calculateSize(request, data);
        var mime = _this4.calculateMime(request, data);
        var originalFileName = _this4.calculateOriginalFileName(request, data);
        return UploadManager_await(_this4.uploadApi.beginMultipartUpload({
          accountId: request.accountId,
          beginMultipartUploadRequest: {
            metadata: request.metadata,
            mime: mime,
            originalFileName: originalFileName,
            path: request.path,
            protocol: "1.1",
            size: size,
            tags: request.tags
          }
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "uploadPart",
    value: function uploadPart(request, data, partIndex, uploadInfo) {
      try {
        var _this6 = this;
        _this6.checkIfCancelled(request);
        return UploadManager_await(_this6.getUploadPart(request, partIndex, uploadInfo), function (part) {
          _this6.checkIfCancelled(request);
          return UploadManager_await(_this6.putUploadPart(part, data), function (etag) {
            _this6.checkIfCancelled(request);
            return UploadManager_awaitIgnored(_this6.uploadApi.completeUploadPart({
              accountId: request.accountId,
              uploadId: uploadInfo.uploadId,
              uploadPartIndex: partIndex,
              completeUploadPartRequest: {
                etag: etag
              }
            }));
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
    /**
     * Returns etag for the part.
     */
  }, {
    key: "putUploadPart",
    value: function putUploadPart(part, data) {
      try {
        var _this8 = this;
        var _a, _b;
        var fetchApi = (_a = _this8.configuration.fetchApi) !== null && _a !== void 0 ? _a : fetch;
        var headers = {
          // Required to prevent fetch using "Transfer-Encoding: Chunked" when body is a stream.
          "content-length": (part.range.inclusiveEnd + 1 - part.range.inclusiveStart).toString()
        };
        var _part$uploadUrl2 = part.uploadUrl,
          _coerceRequestBody2 = _this8.coerceRequestBody;
        return UploadManager_await(_this8.makeRequestBody(part, data), function (_this7$makeRequestBod) {
          return UploadManager_await(fetchApi(_part$uploadUrl2, {
            method: "PUT",
            headers: headers,
            body: _coerceRequestBody2.call(_this8, _this7$makeRequestBod)
          }), function (response) {
            var _exit = false;
            var etag = (_b = response.headers.get("etag")) !== null && _b !== void 0 ? _b : undefined;
            return UploadManager_invoke(function () {
              if (Math.floor(response.status / 100) !== 2) {
                return UploadManager_await(response.text(), function (_response$text) {
                  console.error("Failed to upload part (".concat(response.status, "). Response from server:\n").concat(_response$text));
                  throw new Error("Failed to upload part (".concat(response.status, ")."));
                });
              }
            }, function (_result) {
              if (_exit) return _result;
              if (etag === undefined) {
                throw new Error("No 'etag' response header found in upload part response.");
              }
              return etag;
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "coerceRequestBody",
    value: function coerceRequestBody(data) {
      return data; // node-fetch supports 'NodeJS.ReadableStream'
    }
  }, {
    key: "makeRequestBody",
    value: function makeRequestBody(part, data) {
      try {
        var _this10 = this;
        return UploadManager_await(_this10.sliceDataForRequest(data, part), function (slicedData) {
          var isNodeJs = _this10.isNodeJs();
          // node-fetch requires 'NodeJS.ReadableStream' for the body.
          // browser fetch supports blobs and buffers.
          return UploadManager_await(_this10.foldDataRaw(slicedData, {
            ifBuffer: UploadManager_async(function (buffer) {
              return isNodeJs ? _this10.bufferToStream(buffer) : buffer;
            }),
            ifBlob: UploadManager_async(function (blob) {
              var _bufferToStream = isNodeJs && _this10.bufferToStream;
              return UploadManager_await(isNodeJs ? _this10.blobToBuffer(blob) : blob, function (_this10$blobToBuffer) {
                return isNodeJs ? _bufferToStream.call(_this10, _this10$blobToBuffer) : _this10$blobToBuffer;
              }, !isNodeJs);
            }),
            ifNodeJsStream: function (stream) {
              return UploadManager_await(stream);
            }
          }));
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "bufferToStream",
    value: function bufferToStream(buffer) {
      var readable = new external_stream_.Readable();
      readable._read = function () {}; // _read is required but you can noop it
      readable.push(buffer);
      readable.push(null);
      return readable;
    }
    /**
     * Only expected to be called in Node.js environments, and as such, we can assume 'BlobLike' is not a DOM 'File' object.
     */
  }, {
    key: "blobToBuffer",
    value: function blobToBuffer(blob) {
      try {
        var _exit3 = false;
        // DOM Blob and Node.js Blob both have 'arrayBuffer' with the same signature...
        return UploadManager_invoke(function () {
          if (blob.arrayBuffer !== undefined) {
            _exit3 = true;
            var _Buffer2 = Buffer,
              _from2 = _Buffer2.from;
            return UploadManager_await(blob.arrayBuffer(), function (_blob$arrayBuffer) {
              return _from2.call(_Buffer2, _blob$arrayBuffer);
            });
          }
        }, function (_result2) {
          if (_exit3) return _result2;
          throw new Error("The provided 'data' field was treated as a BLOB, but it does not have an 'arrayBuffer' method.");
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "sliceDataForRequest",
    value: function sliceDataForRequest(data, part) {
      try {
        var _this12 = this;
        if (part.range.inclusiveEnd === -1) {
          return "";
        }
        var start = part.range.inclusiveStart;
        var endExclusive = part.range.inclusiveEnd + 1;
        var partSize = endExclusive - start;
        return UploadManager_await(_this12.foldData(data, {
          ifBlob: UploadManager_async(function (blob) {
            return blob.slice(start, endExclusive);
          }),
          ifBuffer: UploadManager_async(function (buffer) {
            return buffer.subarray(start, endExclusive);
          }),
          ifNodeJsStream: UploadManager_async(function (stream) {
            return stream.take(partSize);
          }) // Assumes stream is read using one worker (which it is).
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "isNodeJs",
    value: function isNodeJs() {
      return typeof process !== "undefined" && process.versions !== undefined && process.versions.node !== undefined;
    }
  }, {
    key: "getUploadPart",
    value: function getUploadPart(request, partIndex, uploadInfo) {
      try {
        var _this14 = this;
        if (partIndex === 0) {
          return uploadInfo.uploadParts.first;
        }
        return UploadManager_await(_this14.uploadApi.getUploadPart({
          uploadId: uploadInfo.uploadId,
          accountId: request.accountId,
          uploadPartIndex: partIndex
        }));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "calculateSize",
    value: function calculateSize(request, data) {
      return this.foldData(data, {
        ifBlob: function ifBlob(blob) {
          return blob.size;
        },
        ifBuffer: function ifBuffer(buffer) {
          return buffer.length;
        },
        ifNodeJsStream: function ifNodeJsStream(_) {
          if (request.size === undefined) {
            throw new Error("You must include the 'size' parameter when using a stream for the 'data' parameter.");
          }
          return request.size;
        }
      });
    }
  }, {
    key: "calculateMime",
    value: function calculateMime(request, data) {
      var _a;
      return (_a = request.mime) !== null && _a !== void 0 ? _a : this.foldData(data, {
        ifBlob: function ifBlob(blob) {
          return blob.type;
        },
        ifBuffer: function ifBuffer(_) {
          return undefined;
        },
        ifNodeJsStream: function ifNodeJsStream(_) {
          return undefined;
        }
      });
    }
  }, {
    key: "calculateOriginalFileName",
    value: function calculateOriginalFileName(request, data) {
      var _a;
      return (_a = request.originalFileName) !== null && _a !== void 0 ? _a : this.foldData(data, {
        ifBlob: function ifBlob(blob) {
          return blob.name;
        },
        ifBuffer: function ifBuffer(_) {
          return undefined;
        },
        ifNodeJsStream: function ifNodeJsStream(_) {
          return undefined;
        }
      });
    }
  }, {
    key: "calculateMaxConcurrency",
    value: function calculateMaxConcurrency(request, data) {
      var _a;
      return (_a = this.foldData(data, {
        ifBlob: function ifBlob(_) {
          return request.maxConcurrentUploadParts;
        },
        ifBuffer: function ifBuffer(_) {
          return request.maxConcurrentUploadParts;
        },
        ifNodeJsStream: function ifNodeJsStream(_) {
          return 1;
        } // Uploading from a stream concurrently is more complex, as would require buffering parts in memory, so we serialize.
      })) !== null && _a !== void 0 ? _a : this.defaultMaxConcurrentUploadParts;
    }
  }, {
    key: "getChunkedStream",
    value: function getChunkedStream(data) {
      return this.foldData(data, {
        ifBlob: function ifBlob(_) {
          return undefined;
        },
        ifBuffer: function ifBuffer(_) {
          return undefined;
        },
        ifNodeJsStream: function ifNodeJsStream(x) {
          return x;
        }
      });
    }
  }, {
    key: "foldData",
    value: function foldData(data, handle) {
      if (data instanceof ChunkedStream) {
        return handle.ifNodeJsStream(data);
      }
      if (data.subarray !== undefined) {
        return handle.ifBuffer(data);
      }
      if (data.slice !== undefined) {
        return handle.ifBlob(data);
      }
      throw new Error("Unsupported type for 'data' parameter. Please provide a String, Blob, or Readable (Node.js).");
    }
  }, {
    key: "foldDataRaw",
    value: function foldDataRaw(data, handle) {
      try {
        var _exit8 = false;
        var _this16 = this;
        return UploadManager_invoke(function () {
          if (typeof data === "string") {
            _exit8 = true;
            var _ifBlob2 = handle.ifBlob;
            return UploadManager_await(_this16.stringToBlob(data), function (_this15$stringToBlob) {
              return UploadManager_await(_ifBlob2.call(handle, _this15$stringToBlob));
            });
          }
        }, function (_result3) {
          var _exit5 = false;
          if (_exit8) return _result3;
          return UploadManager_invoke(function () {
            if (data.on !== undefined) {
              _exit5 = true;
              return UploadManager_await(handle.ifNodeJsStream(data));
            }
          }, function (_result4) {
            var _exit6 = false;
            if (_exit5) return _result4;
            return UploadManager_invoke(function () {
              if (data.subarray !== undefined) {
                _exit6 = true;
                return UploadManager_await(handle.ifBuffer(data));
              }
            }, function (_result5) {
              var _exit7 = false;
              if (_exit6) return _result5;
              return UploadManager_invoke(function () {
                if (data.slice !== undefined) {
                  _exit7 = true;
                  return UploadManager_await(handle.ifBlob(data));
                }
              }, function (_result6) {
                if (_exit7) return _result6;
                throw new Error("Unsupported type for 'data' parameter. Please provide a String, Blob, or Readable (Node.js).");
              });
            });
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "processUploadSource",
    value: function processUploadSource(data) {
      try {
        var _exit10 = false;
        var _this18 = this;
        return UploadManager_invoke(function () {
          if (typeof data === "string") {
            _exit10 = true;
            return UploadManager_await(_this18.stringToBlob(data));
          }
        }, function (_result7) {
          if (_exit10) return _result7;
          if (data.on !== undefined) {
            return new ChunkedStream(data);
          }
          if (data.subarray !== undefined) {
            return data;
          }
          if (data.slice !== undefined) {
            return data;
          }
          throw new Error("Unsupported type for 'data' parameter. Please provide a String, Blob, or Readable (Node.js).");
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "stringToBlob",
    value: function stringToBlob(data) {
      try {
        var _this20 = this;
        var _a;
        var _temp2 = (_a = _this20.globalBlob(data)) !== null && _a !== void 0;
        return UploadManager_await(_temp2 ? _a : _this20.nodeJsBlob(data), void 0, _temp2);
      } catch (e) {
        return Promise.reject(e);
      }
    } // Supported by browsers & newer versions of Node.js.
  }, {
    key: "globalBlob",
    value: function globalBlob(data) {
      var B = globalThis.Blob;
      if (B === undefined) {
        return undefined;
      }
      return new B([data], {
        type: this.stringMimeType
      });
    }
    // Fallback for Node.js
  }, {
    key: "nodeJsBlob",
    value: function nodeJsBlob(data) {
      try {
        var _this22 = this;
        // We import "buffer" lazily to support browsers, which don't have this module, but also won't call this method so won't trigger the import.
        return UploadManager_await(Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, "buffer")), function (_import) {
          var bufferModule = _import["default"];
          var B = bufferModule.Blob;
          return new B([data], {
            type: _this22.stringMimeType
          });
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }, {
    key: "mapAsync",
    value: function mapAsync(items, concurrency, callback) {
      try {
        var workQueue = UploadManager_toConsumableArray(items);
        return UploadManager_awaitIgnored(Promise.all(UploadManager_toConsumableArray(Array(concurrency).keys()).map(UploadManager_async(function () {
          return _continueIgnored(_for(function () {
            return workQueue.length > 0;
          }, void 0, function () {
            var work = workQueue.shift(); // IMPORTANT: use 'shift' instead of 'pop' to ensure 'items' are processed in order when 'concurrency = 1'.
            return UploadManager_invokeIgnored(function () {
              if (work !== undefined) {
                return UploadManager_awaitIgnored(callback(work));
              }
            });
          }));
        }))));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  }]);
  return UploadManager;
}();
;// CONCATENATED MODULE: ./src/utils/index.ts



;// CONCATENATED MODULE: ./src/index.ts
/* tslint:disable */
/* eslint-disable */


}();
var __webpack_exports__AccountJobStatus = __webpack_exports__.AccountJobStatus;
var __webpack_exports__AccountJobType = __webpack_exports__.AccountJobType;
var __webpack_exports__AsyncResponseJobDocsEnum = __webpack_exports__.AsyncResponseJobDocsEnum;
var __webpack_exports__AwsRegion = __webpack_exports__.AwsRegion;
var __webpack_exports__BASE_PATH = __webpack_exports__.BASE_PATH;
var __webpack_exports__BaseAPI = __webpack_exports__.BaseAPI;
var __webpack_exports__BinaryResult = __webpack_exports__.BinaryResult;
var __webpack_exports__COLLECTION_FORMATS = __webpack_exports__.COLLECTION_FORMATS;
var __webpack_exports__CancelledError = __webpack_exports__.CancelledError;
var __webpack_exports__ChunkedStream = __webpack_exports__.ChunkedStream;
var __webpack_exports__Configuration = __webpack_exports__.Configuration;
var __webpack_exports__DefaultConfig = __webpack_exports__.DefaultConfig;
var __webpack_exports__FetchError = __webpack_exports__.FetchError;
var __webpack_exports__FileApi = __webpack_exports__.FileApi;
var __webpack_exports__FileCopyStatus = __webpack_exports__.FileCopyStatus;
var __webpack_exports__FileSummaryTypeEnum = __webpack_exports__.FileSummaryTypeEnum;
var __webpack_exports__FolderApi = __webpack_exports__.FolderApi;
var __webpack_exports__FolderDetailsTypeEnum = __webpack_exports__.FolderDetailsTypeEnum;
var __webpack_exports__FolderSettingsStorageLayerSummaryStorageLayerTypeEnum = __webpack_exports__.FolderSettingsStorageLayerSummaryStorageLayerTypeEnum;
var __webpack_exports__FolderSummaryTypeEnum = __webpack_exports__.FolderSummaryTypeEnum;
var __webpack_exports__InternalStorageV1TypeEnum = __webpack_exports__.InternalStorageV1TypeEnum;
var __webpack_exports__InternalStorageV2TypeEnum = __webpack_exports__.InternalStorageV2TypeEnum;
var __webpack_exports__JSONApiResponse = __webpack_exports__.JSONApiResponse;
var __webpack_exports__JobApi = __webpack_exports__.JobApi;
var __webpack_exports__MultipartUploadProtocol = __webpack_exports__.MultipartUploadProtocol;
var __webpack_exports__ObjectSummaryTypeEnum = __webpack_exports__.ObjectSummaryTypeEnum;
var __webpack_exports__PathPermissionScope = __webpack_exports__.PathPermissionScope;
var __webpack_exports__PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum = __webpack_exports__.PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum;
var __webpack_exports__ProcessFileCachePermEnum = __webpack_exports__.ProcessFileCachePermEnum;
var __webpack_exports__RequiredError = __webpack_exports__.RequiredError;
var __webpack_exports__ResponseError = __webpack_exports__.ResponseError;
var __webpack_exports__S3StorageTypeEnum = __webpack_exports__.S3StorageTypeEnum;
var __webpack_exports__SpecifiedFieldValueFolderDescriptionOrNullSetEnum = __webpack_exports__.SpecifiedFieldValueFolderDescriptionOrNullSetEnum;
var __webpack_exports__SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum = __webpack_exports__.SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum;
var __webpack_exports__SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum = __webpack_exports__.SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum;
var __webpack_exports__SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum = __webpack_exports__.SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum;
var __webpack_exports__StorageLayerSummaryTypeEnum = __webpack_exports__.StorageLayerSummaryTypeEnum;
var __webpack_exports__StorageLayerUpdateTypeEnum = __webpack_exports__.StorageLayerUpdateTypeEnum;
var __webpack_exports__TagConditionAllTypeEnum = __webpack_exports__.TagConditionAllTypeEnum;
var __webpack_exports__TagConditionAndTypeEnum = __webpack_exports__.TagConditionAndTypeEnum;
var __webpack_exports__TagConditionAnyTypeEnum = __webpack_exports__.TagConditionAnyTypeEnum;
var __webpack_exports__TagConditionEqualsTypeEnum = __webpack_exports__.TagConditionEqualsTypeEnum;
var __webpack_exports__TagConditionNotTypeEnum = __webpack_exports__.TagConditionNotTypeEnum;
var __webpack_exports__TagConditionOrTypeEnum = __webpack_exports__.TagConditionOrTypeEnum;
var __webpack_exports__TagConditionTypeEnum = __webpack_exports__.TagConditionTypeEnum;
var __webpack_exports__TextApiResponse = __webpack_exports__.TextApiResponse;
var __webpack_exports__UnspecifiedFieldValueSetEnum = __webpack_exports__.UnspecifiedFieldValueSetEnum;
var __webpack_exports__UpdatableFieldFolderDescriptionOrNullSetEnum = __webpack_exports__.UpdatableFieldFolderDescriptionOrNullSetEnum;
var __webpack_exports__UpdatableFieldPublicPermissionsArrayOrNullSetEnum = __webpack_exports__.UpdatableFieldPublicPermissionsArrayOrNullSetEnum;
var __webpack_exports__UpdatableFieldStorageLayerUpdateOrNullSetEnum = __webpack_exports__.UpdatableFieldStorageLayerUpdateOrNullSetEnum;
var __webpack_exports__UploadApi = __webpack_exports__.UploadApi;
var __webpack_exports__UploadApiError = __webpack_exports__.UploadApiError;
var __webpack_exports__UploadManager = __webpack_exports__.UploadManager;
var __webpack_exports__VoidApiResponse = __webpack_exports__.VoidApiResponse;
var __webpack_exports__WebStorageTypeEnum = __webpack_exports__.WebStorageTypeEnum;
var __webpack_exports__canConsumeForm = __webpack_exports__.canConsumeForm;
var __webpack_exports__querystring = __webpack_exports__.querystring;
export { __webpack_exports__AccountJobStatus as AccountJobStatus, __webpack_exports__AccountJobType as AccountJobType, __webpack_exports__AsyncResponseJobDocsEnum as AsyncResponseJobDocsEnum, __webpack_exports__AwsRegion as AwsRegion, __webpack_exports__BASE_PATH as BASE_PATH, __webpack_exports__BaseAPI as BaseAPI, __webpack_exports__BinaryResult as BinaryResult, __webpack_exports__COLLECTION_FORMATS as COLLECTION_FORMATS, __webpack_exports__CancelledError as CancelledError, __webpack_exports__ChunkedStream as ChunkedStream, __webpack_exports__Configuration as Configuration, __webpack_exports__DefaultConfig as DefaultConfig, __webpack_exports__FetchError as FetchError, __webpack_exports__FileApi as FileApi, __webpack_exports__FileCopyStatus as FileCopyStatus, __webpack_exports__FileSummaryTypeEnum as FileSummaryTypeEnum, __webpack_exports__FolderApi as FolderApi, __webpack_exports__FolderDetailsTypeEnum as FolderDetailsTypeEnum, __webpack_exports__FolderSettingsStorageLayerSummaryStorageLayerTypeEnum as FolderSettingsStorageLayerSummaryStorageLayerTypeEnum, __webpack_exports__FolderSummaryTypeEnum as FolderSummaryTypeEnum, __webpack_exports__InternalStorageV1TypeEnum as InternalStorageV1TypeEnum, __webpack_exports__InternalStorageV2TypeEnum as InternalStorageV2TypeEnum, __webpack_exports__JSONApiResponse as JSONApiResponse, __webpack_exports__JobApi as JobApi, __webpack_exports__MultipartUploadProtocol as MultipartUploadProtocol, __webpack_exports__ObjectSummaryTypeEnum as ObjectSummaryTypeEnum, __webpack_exports__PathPermissionScope as PathPermissionScope, __webpack_exports__PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum as PickS3StorageExcludeKeyofS3StorageCredentialsTypeEnum, __webpack_exports__ProcessFileCachePermEnum as ProcessFileCachePermEnum, __webpack_exports__RequiredError as RequiredError, __webpack_exports__ResponseError as ResponseError, __webpack_exports__S3StorageTypeEnum as S3StorageTypeEnum, __webpack_exports__SpecifiedFieldValueFolderDescriptionOrNullSetEnum as SpecifiedFieldValueFolderDescriptionOrNullSetEnum, __webpack_exports__SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum as SpecifiedFieldValuePublicPermissionsArrayOrNullSetEnum, __webpack_exports__SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum as SpecifiedFieldValueStorageLayerUpdateOrNullSetEnum, __webpack_exports__SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum as SpecifiedFieldValueStorageLayerUpdateOrNullValueTypeEnum, __webpack_exports__StorageLayerSummaryTypeEnum as StorageLayerSummaryTypeEnum, __webpack_exports__StorageLayerUpdateTypeEnum as StorageLayerUpdateTypeEnum, __webpack_exports__TagConditionAllTypeEnum as TagConditionAllTypeEnum, __webpack_exports__TagConditionAndTypeEnum as TagConditionAndTypeEnum, __webpack_exports__TagConditionAnyTypeEnum as TagConditionAnyTypeEnum, __webpack_exports__TagConditionEqualsTypeEnum as TagConditionEqualsTypeEnum, __webpack_exports__TagConditionNotTypeEnum as TagConditionNotTypeEnum, __webpack_exports__TagConditionOrTypeEnum as TagConditionOrTypeEnum, __webpack_exports__TagConditionTypeEnum as TagConditionTypeEnum, __webpack_exports__TextApiResponse as TextApiResponse, __webpack_exports__UnspecifiedFieldValueSetEnum as UnspecifiedFieldValueSetEnum, __webpack_exports__UpdatableFieldFolderDescriptionOrNullSetEnum as UpdatableFieldFolderDescriptionOrNullSetEnum, __webpack_exports__UpdatableFieldPublicPermissionsArrayOrNullSetEnum as UpdatableFieldPublicPermissionsArrayOrNullSetEnum, __webpack_exports__UpdatableFieldStorageLayerUpdateOrNullSetEnum as UpdatableFieldStorageLayerUpdateOrNullSetEnum, __webpack_exports__UploadApi as UploadApi, __webpack_exports__UploadApiError as UploadApiError, __webpack_exports__UploadManager as UploadManager, __webpack_exports__VoidApiResponse as VoidApiResponse, __webpack_exports__WebStorageTypeEnum as WebStorageTypeEnum, __webpack_exports__canConsumeForm as canConsumeForm, __webpack_exports__querystring as querystring };
